/ *! jQuery v3.3.1 | (c) Fondation JS et autres contributeurs | jquery.org/license * /! fonction (e, t) {
    "utiliser strict";
    "object" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): fonction (e) {
        if (! e.document) throw new Error ("jQuery nécessite une fenêtre avec un document");
        retour t (e)
    }: t (e)
} ("indéfini"! = type de fenêtre? window: this, function (e, t) {
    "utiliser strict";
    var n = [],
        r = document électronique,
        i = Object.getPrototypeOf,
        o = n.slice,
        a = n.concat,
        s = n.pousser,
        u = n.indexOf,
        l = {},
        c = l.toString,
        f = l.hasOwnProperty,
        p = f.toString,
        d = p.call (objet),
        h = {},
        g = fonction e (t) {
            return "function" == typeof t && "number"! = typeof t.nodeType
        },
        y = fonction e (t) {
            retourne null! = t && t === t.window
        },
        v = {
            tapez:! 0,
            src:! 0,
            noModule:! 0
        };

    fonction m (e, t, n) {
        var i, o = (t = t || r) .createElement ("script");
        si (o.text = e, n)
            pour (i dans v) n [i] && (o [i] = n [i]);
        t.head.appendChild (o) .parentNode.removeChild (o)
    }

    fonction x (e) {
        retourne null == e? e + "": "objet" == type de e || "fonction" == type de e? l [c.call (e)] || "objet": type de e
    }
    var b = "3.3.1",
        w = fonction (e, t) {
            retourne nouveau w.fn.init (e, t)
        },
        T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g;
    w.fn = w.prototype = {
        jquery: "3.3.1",
        constructeur: w,
        longueur: 0,
        toArray: function () {
            return o.call (this)
        },
        get: function (e) {
            retourne null == e? o. appeler (ceci): e <0? this [e + this.length]: ce [e]
        },
        pushStack: fonction (e) {
            var t = w.merge (ce.constructeur (), e);
            retourne t.prevObject = this, t
        },
        chacun: function (e) {
            retour avec chacun (ceci, e)
        },
        carte: fonction (e) {
            retourne this.pushStack (w.map (this, function (t, n) {
                retourne e.call (t, n, t)
            }))
        },
        tranche: function () {
            retourne this.pushStack (o.apply (this, arguments))
        },
        d'abord: function () {
            renvoie this.eq (0)
        },
        dernier: function () {
            renvoie this.eq (-1)
        },
        eq: fonction (e) {
            var t = this.length,
                n = + e + (e <0? t: 0);
            renvoie this.pushStack (n> = 0 && n <t? [this [n]]: [])
        },
        fin: function () {
            renvoyer this.prevObject || this.constructor ()
        },
        pousser: s,
        trier: n.sort,
        épissure: n. épissure
    }, w.extend = w.fn.extend = function () {
        var e, t, n, r, i, o, a = arguments [0] || {},
            s = 1,
            u = arguments.longueur,
            l =! 1;
        for ("boolean" == typeof a && (l = a, a = arguments [s] || {}, s ++), "object" == typeof a || g (a) || (a = {}) , s === u && (a = ceci, s--); s <u; s ++)
            if (nul! = (e = arguments [s]))
                pour (t dans e) n = a [t], a! == (r = e [t]) && (l && r && (w.isPlainObject (r) || (i = Array.isArray (r)) )? (i? (i =! 1, o = n && Array.isArray (n)? n: []): o = n && w.isPlainObject (n)? n: {}, a [t] = w .extend (l, o, r)): void 0! == r && (a [t] = r));
        retourner un
    }, w.extend ({
        expando: "jQuery" + ("3.3.1" + Math.random ()). replace (/ \ D / g, ""),
        isReady:! 0,
        erreur: function (e) {
            lancer une nouvelle erreur (e)
        },
        noop: function () {},
        isPlainObject: function (e) {
            var t, n;
            return! (! e || "[Objet Objet]"! == c.call (e)) && (! (t = i (e)) || "function" == typeof (n = f.call (t , "constructeur") && t.constructor) && p.call (n) === d)
        },
        isEmptyObject: function (e) {
            var t;
            pour (t dans e) return! 1;
            retour! 0
        },
        globalEval: function (e) {
            moi)
        },
        chacun: function (e, t) {
            var n, r = 0;
            si (C (e)) {
                pour (n = e.length; r <n; r ++)
                    if (! 1 === t.call (e [r], r, e [r])) break
            } autre
                pour (r dans e)
                    if (! 1 === t.call (e [r], r, e [r])) break;
            retour e
        },
        trim: fonction (e) {
            retourne null == e? "": (e + "") .replace (T, "")
        },
        makeArray: fonction (e, t) {
            var n = t || [];
            retourne null! = e && (C (Object (e))? w.merge (n, "string" == typeof e? [e]: e): s.call (n, e)), n
        },
        inArray: function (e, t, n) {
            retourne null == t? -1: u.call (t, e, n)
        },
        merge: function (e, t) {
            pour (var n = + t.length, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r];
            retourne e.length = i, e
        },
        grep: fonction (e, t, n) {
            pour (var r, i = [], o = 0, a = e.longueur, s =! n; o <a; o ++) (r =! t (e [o], o))! == s && i.push (e [o]);
            retourne je
        },
        carte: fonction (e, t, n) {
            var r, i, o = 0,
                s = [];
            si (C (e))
                pour (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && s.push (i);
            autre
                pour (o dans e) nul! = (i = t (e [o], o, n)) && s.push (i);
            retourne a.apply ([], s)
        },
        guid: 1,
        support: h
    }), "function" == typeof Symbol && (w.fn [Symbol.iterator] = n [Symbol.iterator]), w.each ("Boolean Number String Function Array Date RegExp Object Error Symbol" .split ("" ), fonction (e, t) {
        l ["[objet" + t + "]"] = t.toLowerCase ()
    });

    fonction C (e) {
        var t = !! e && "longueur" dans e && e.length,
            n = x (e);
        retourne! g (e) &&! y (e) && ("tableau" === n || 0 === t || "nombre" == type de t && t> 0 && t - 1 dans e)
    }
    var E = fonction (e) {
        var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v, m, x, b = "grésillement" + 1 * nouvelle date,
            w = document électronique,
            T = 0,
            C = 0,
            E = ae (),
            k = ae (),
            S = ae (),
            D = fonction (e, t) {
                renvoie e === t && (f =! 0), 0
            },
            N = {} .hasOwnProperty,
            A = [],
            j = A.pop,
            q = A.pousser,
            L = A.pousser,
            H = A.slice,
            O = fonction (e, t) {
                pour (var n = 0, r = e.length; n <r; n ++)
                    si (e [n] === t) renvoie n;
                retour -1
            },
            P = "coché | sélectionné | asynchrone | autofocus | lecture automatique | contrôles | différer | désactivé | masqué | ismap | boucle | multiple | ouvert | lecture seule | requis | cadré",
            M = "[\\ x20 \\ t \\ r \\ n \\ f]",
            R = "(?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) +",
            I = "\\ [" + M + "* (" + R + ") (?:" + M + "* ([* ^ $ |! ~]? =)" + M + "* (?: ' ((?: \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| ("+ R +")) |) "+ M +" * \\] ",
            W = ":(" + R + ") (?: \\ ((('((?: \\\\. | [^ \\\\']) *) '| \" ((?: \ \\\. | [^ \\\\\ "]) *) \") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ I +" ) *) |. *) \\) |) ",
            $ = new RegExp (M + "+", "g"),
            B = new RegExp ("^" + M + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + M + "+ $", "g "),
            F = new RegExp ("^" + M + "*," + M + "*"),
            _ = new RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"),
            z = new RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "),
            X = nouveau RegExp (W),
            U = new RegExp ("^" + R + "$"),
            V = {
                ID: nouveau RegExp ("^ # (" + R + ")"),
                CLASS: nouveau RegExp ("^ \\. (" + R + ")"),
                TAG: new RegExp ("^ (" + R + "| [*])"),
                ATTR: nouveau RegExp ("^" + I),
                PSEUDO: nouveau RegExp ("^" + W),
                CHILD: new RegExp ("^ :( seulement | premier | dernier | nième | nième-dernier) - (enfant | de-type) (?: \\ (" + M + "* (pair | impair | (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \ \) |) "," i "),
                booléen: new RegExp ("^ (?:" + P + ") $", "i"),
                needsContext: new RegExp ("^" + M + "* [> + ~] |: (pair | impair | eq | gt | lt | nième | premier | dernier) (?: \\ (" + M + "* ( (?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")
            },
            G = / ^ (?: input | select | textarea | button) $ / i,
            Y = / ^ h \ d $ / i,
            Q = / ^ [^ {] + \ {\ s * \ [natif \ w /,
            J = /^(?:#([\w- </font>+)|(\w+)|\.([\w- </font>+))$/,
            K = / [+ ~] /,
            Z = new RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "? | (" + M + ") |.)", "Ig"),
            ee = fonction (e, t, n) {
                var r = "0x" + t - 65536;
                retourne r! == r || n? t: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296, 1023 & r | 56320)
            },
            te = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g,
            ne = fonction (e, t) {
                retour t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length - 1) .toString (16) + "": "\\" + e
            },
            re = fonction () {
                p ()
            },
            ie = moi (fonction (e) {
                return! 0 === e.disabled && ("form" in e || "label" in e)
            }, {
                dir: "parentNode",
                suivant: "légende"
            });
        essayez {
            L.apply (A = H.call (w.childNodes), w.childNodes), A [w.childNodes.length] .nodeType
        } catch (e) {
            L = {
                appliquer: A.longueur? fonction (e, t) {
                    q.apply (e, H.call (t))
                }: fonction (e, t) {
                    var n = longueur e,
                        r = 0;
                    tandis que (e [n ++] = t [r ++]);
                    e.longueur = n - 1
                }
            }
        }

        fonction oe (e, t, r, i) {
            var o, s, l, c, f, h, v, m = t && t.ownerDocument,
                T = t? t.nodeType: 9;
            if (r = r || [], "string"! = typeof e ||! e || 1! == T && 9! == T && 11! == T) return r;
            si (! i && ((t? t.ownerDocument || t: w)! == d && p (t), t = t || d, g)) {
                si (11! == T && (f = J.exec (e)))
                    si (o = f [1]) {
                        si (9 === T) {
                            if (! (l = t.getElementById (o))) return r;
                            if (l.id === o) renvoie r.push (l), r
                        } else if (m && (l = m.getElementById (o)) && x (t, l) && l.id === o) retourne r.push (l), r
                    } autre {
                        if (f [2]) renvoie L.apply (r, t.getElementsByTagName (e)), r;
                        if ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) renvoie L.apply (r, t.getElementsByClassName (o)), r
                    } si (n.qsa &&! S [e + ""] && (! y ||! y.test (e))) {
                    si (1! == T) m = t, v = e;
                    else if ("objet"! == t.nodeName.toLowerCase ()) {
                        (c = t.getAttribute ("id"))? c = c.replace (te, ne): t.setAttribute ("id", c = b), s = (h = a (e)). length;
                        while (s--) h [s] = "#" + c + "" + ve (h [s]);
                        v = h.join (","), m = K.test (e) && ge (t.parentNode) || t
                    }
                    si (v) essayez {
                        renvoie L.apply (r, m.querySelectorAll (v)), r
                    } catch (e) {} enfin {
                        c === b && t.removeAttribute ("id")
                    }
                }
            }
            retourne u (e.replace (B, "$ 1"), t, r, i)
        }

        function ae () {
            var e = [];

            fonction t (n, i) {
                return e.push (n + "")> r.cacheLength && delete t [e.shift ()], t [n + ""] = i
            }
            retour t
        }

        fonction se (e) {
            renvoie e [b] =! 0, e
        }

        fonction ue (e) {
            var t = d.createElement ("fieldset");
            essayez {
                retour !! e (t)
            } catch (e) {
                retour! 1
            } enfin {
                t.parentNode && t.parentNode.removeChild (t), t = null
            }
        }

        function le (e, t) {
            var n = e.split ("|"),
                i = n.longueur;
            tandis que (i--) r.attrHandle [n [i]] = t
        }

        fonction ce (e, t) {
            var n = t && e,
                r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
            si (r) renvoie r;
            si (n)
                tandis que (n = n.nextSibling)
                    si (n === t) renvoie -1;
            retour e? 1: -1
        }

        fonction fe (e) {
            fonction de retour (t) {
                retourne "input" === t.nodeName.toLowerCase () && t.type === e
            }
        }

        fonction pe (e) {
            fonction de retour (t) {
                var n = t.nodeName.toLowerCase ();
                return ("entrée" === n || "bouton" === n) && t.type === e
            }
        }

        fonction de (e) {
            fonction de retour (t) {
                retourne "forme" en t? t.parentNode &&! 1 === t.disabled? "label" en t? "label" dans t.parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e && ie (t) === e: t.disabled === e: "label" in t && t.disabled === e
            }
        }

        fonction he (e) {
            return se (fonction (t) {
                retourne t = + t, se (fonction (n, r) {
                    var i, o = e ([], n.longueur, t),
                        a = o.longueur;
                    tandis que (a--) n [i = o [a]] && (n [i] =! (r [i] = n [i]))
                })
            })
        }

        function ge (e) {
            renvoie e && "undefined"! = typeof e.getElementsByTagName && e
        }
        n = oe.support = {}, o = oe.isXML = fonction (e) {
            var t = e && (e.ownerDocument || e) .documentElement;
            return !! t && "HTML"! == t.nodeName
        }, p = oe.setDocument = fonction (e) {
            var t, i, a = e? e.ownerDocument || e: w;
            retourne a! == d && 9 === a.nodeType && a.documentElement? (d = a, h = d.documentElement, g =! o (d), w! == d && (i = d.defaultView) && i.top! == i && (i.addEventListener? i.addEventListener ( "unload", re,! 1): i.attachEvent && i.attachEvent ("onunload", re)), n.attributes = ue (function (e) {
                return e.className = "i",! e.getAttribute ("className")
            }), n.getElementsByTagName = ue (fonction (e) {
                return e.appendChild (d.createComment ("")),! e.getElementsByTagName ("*"). length
            }), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (fonction (e) {
                retourne h.appendChild (e) .id = b,! d.getElementsByName || ! d.getElementsByName (b) .length
            }), n.getById? (r.filter.ID = fonction (e) {
                var t = e. remplacer (Z, ee);
                fonction de retour (e) {
                    retourne e.getAttribute ("id") === t
                }
            }, r.find.ID = fonction (e, t) {
                if ("undefined"! = typeof t.getElementById && g) {
                    var n = t.getElementById (e);
                    retourner n? [n]: []
                }
            }): (r.filter.ID = fonction (e) {
                var t = e. remplacer (Z, ee);
                fonction de retour (e) {
                    var n = "undefined"! = typeof e.getAttributeNode && e.getAttributeNode ("id");
                    renvoie n && n.value === t
                }
            }, r.find.ID = fonction (e, t) {
                if ("undefined"! = typeof t.getElementById && g) {
                    var n, r, i, o = t.getElementById (e);
                    if (o) {
                        if ((n = o.getAttributeNode ("id")) && n.value === e) return [o];
                        i = t.getElementsByName (e), r = 0;
                        tandis que (o = i [r ++])
                            if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]
                    }
                    revenir []
                }
            }), r.find.TAG = n.getElementsByTagName? fonction (e, t) {
                return "undefined"! = typeof t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0
            }: fonction (e, t) {
                var n, r = [],
                    i = 0,
                    o = t.getElementsByTagName (e);
                if ("*" === e) {
                    while (n = o [i ++]) 1 === n.nodeType && r.push (n);
                    retour r
                }
                retour o
            }, r.find.CLASS = n.getElementsByClassName && function (e, t) {
                if ("undefined"! = typeof t.getElementsByClassName && g) retourne t.getElementsByClassName (e)
            }, v = [], y = [], (n.qsa = Q.test (d.querySelectorAll)) && (ue (fonction (e) {
                h.appendChild (e) .innerHTML = "<a id='" + b + "'> </a> <select id = '" + b + "- \ r \\' msallowcapture = ''> <option sélectionnée = ''> </option> </select> ", e.querySelectorAll (" [msallowcapture ^ = ''] "). length && y.push (" [* ^ $] = "+ M +" * (? : '' | \ "\") "), e.querySelectorAll (" [selected] "). length || y.push ("\\ [" + M + "* (?: valeur |" + P + ")"), e.querySelectorAll ("[id ~ =" + b + "-]"). length || y.push ("~ ="), e.querySelectorAll (": vérifié"). longueur || y.push (": vérifié"), e.querySelectorAll ("a #" + b + "+ *"). length || y.push (". #. + [+ ~]")
            }), ue (fonction (e) {
                e.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <option /> </select>";
                var t = d.createElement ("entrée");
                t.setAttribute ("type", "hidden"), e.appendChild (t) .setAttribute ("name", "D"), e.querySelectorAll ("[name = d]"). length && y.push ( "nom" + M + "* [* ^ $ |! ~]? ="), 2! == e.querySelectorAll (": enabled"). length && y.push (": enabled", ": disabled" ), h.appendChild (e) .disabled =! 0, 2! == e.querySelectorAll (": disabled"). length && y.push (": enabled", ": disabled"), e.querySelectorAll (" * ,: x "), y.push (",. *: ")
            })), (n.matchesSelector = Q.test (m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue (function (e) {
                n.disconnectedMatch = m.call (e, "*"), m.call (e, "[s! = '']: x"), v.push ("! =", W)
            }), y = y.length && new RegExp (y.join ("|")), v = v.length && new RegExp (v.join ("|")), t = Q.test (h.compareDocumentPosition ), x = t || Q.test (h. Contient)? fonction (e, t) {
                var n = 9 === e.nodeType? e.documentElement: e,
                    r = t && t.parentNode;
                retourne e === r || ! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))
            }: fonction (e, t) {
                si (t)
                    while (t = t.parentNode)
                        if (t === e) retourne! 0;
                retour! 1
            }, D = t? fonction (e, t) {
                if (e === t) renvoie f =! 0, 0;
                var r =! e.compareDocumentPosition -! t.compareDocumentPosition;
                retour r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t)? E.compareDocumentPosition (t): 1) ||! N.sortDetached && t.compareDocumentPosition (e) == = r? e === d || e.ownerDocument === w && x (w, e)? -1: t === d || t.ownerDocument === w && x (w, t)? 1: c? O (c, e) - O (c, t): 0: 4 & r? -1: 1)
            }: fonction (e, t) {
                if (e === t) renvoie f =! 0, 0;
                var n, r = 0,
                    i = e.parentNode,
                    o = t.parentNode,
                    a = [e],
                    s = [t];
                si (! i ||! o) renvoie e === d? -1: t === d? 1: je? -1: o? 1: c? O (c, e) - O (c, t): 0;
                if (i === o) retourne ce (e, t);
                n = e;
                while (n = n.parentNode) a.unshift (n);
                n = t;
                while (n = n.parentNode) s.unshift (n);
                while (a [r] === s [r]) r ++;
                retourner r? ce (a [r], s [r]): a [r] === w? -1: s [r] === w? dix
            }, d): d
        }, oe.matches = fonction (e, t) {
            retourne oe (e, null, null, t)
        }, oe.matchesSelector = fonction (e, t) {
            if ((e.ownerDocument || e)! == d && p (e), t = t.replace (z, "= '$ 1']"), n.matchesSelector && g &&! S [t + "" ] && (! v ||! v.test (t)) && (! y ||! y.test (t))) essayez {
                var r = m.call (e, t);
                if (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType) retourne r
            } catch (e) {}
            renvoie oe (t, d, null, [e]). longueur> 0
        }, oe.contains = fonction (e, t) {
            return (e.ownerDocument || e)! == d && p (e), x (e, t)
        }, oe.attr = fonction (e, t) {
            (e.ownerDocument || e)! == d && p (e);
            var i = r.attrHandle [t.toLowerCase ()],
                o = i && N.call (r.attrHandle, t.toLowerCase ())? i (e, t,! g): vide 0;
            return void 0! == o? o: n.attributs || !g ? e.getAttribute (t): (o = e.getAttributeNode (t)) && o.specified? o.value: null
        }, oe.escape = fonction (e) {
            return (e + "") .replace (te, ne)
        }, oe.error = fonction (e) {
            throw new Error ("Erreur de syntaxe, expression non reconnue:" + e)
        }, oe.uniqueSort = fonction (e) {
            var t, r = [],
                i = 0,
                o = 0;
            if (f =! n.detectDuplicates, c =! n.sortStable && e.slice (0), e.sort (D), f) {
                tandis que (t = e [o ++]) t === e [o] && (i = r.push (o));
                tandis que (i--) e.splice (r [i], 1)
            }
            retourne c = null, e
        }, i = oe.getText = fonction (e) {
            var t, n = "",
                r = 0,
                o = e.nodeType;
            if (o) {
                si (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    pour (e = e.firstChild; e; e = e.nextSibling) n + = i (e)
                } else if (3 === o || 4 === o) renvoie e.nodeValue
            } autre
                tandis que (t = e [r ++]) n + = i (t);
            retour n
        }, (r = sélecteurs oe. = {
            cacheLongueur: 50,
            createPseudo: se,
            match: V,
            attrHandle: {},
            trouver: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    premier:! 0
                },
                "": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    premier:! 0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: fonction (e) {
                    renvoie e [1] = e [1] .replace (Z, ee), e [3] = (e [3] || e [4] || e [5] || "") .replace (Z, ee), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0, 4)
                },
                ENFANT: function (e) {
                    renvoie e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0, 3)? (e [3] || oe.error (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair" === e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3] )): e [3] && oe.error (e [0]), e
                },
                PSEUDO: fonction (e) {
                    var t, n =! e [6] && e [2];
                    retourner V.CHILD.test (e [0])? nul: (e [3]? e [2] = e [4] || e [5] || "": n && X.test (n) && (t = a (n,! 0)) && ( t = n.indexOf (")", n.length - t) - n.length) && (e [0] = e [0] .slice (0, t), e [2] = n.slice (0 , t)), e.slice (0, 3))
                }
            },
            filtre: {
                TAG: fonction (e) {
                    var t = e.replace (Z, ee) .toLowerCase ();
                    retourne "*" === e? fonction () {
                        retour! 0
                    }: fonction (e) {
                        retourne e.nodeName && e.nodeName.toLowerCase () === t
                    }
                },
                CLASSE: fonction (e) {
                    var t = E [e + ""];
                    retour t || (t = new RegExp ("(^ |" + M + ")" + e + "(" + M + "| $)")) && E (e, fonction (e) {
                        return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")
                    })
                },
                ATTR: fonction (e, t, n) {
                    fonction de retour (r) {
                        var i = oe.attr (r, e);
                        renvoie null == i? "! =" === t:! t || (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ =" === t? n && 0 == = i.indexOf (n): "* =" === t? n && i.indexOf (n)> -1: "$ =" === t? n && i.slice (-n.length) = == n: "~ =" === t? ("" + i.replace ($, "") + "") .indexOf (n)> -1: "| =" === t && (i === n || i.slice (0, n.longueur + 1) === n + "-"))
                    }
                },
                ENFANT: fonction (e, t, n, r, i) {
                    var o = "nième"! == e.slice (0, 3),
                        a = "dernier"! == e.slice (-4),
                        s = "de type" === t;
                    renvoie 1 === r && 0 === i? fonction (e) {
                        retour !! e.parentNode
                    }: fonction (t, n, u) {
                        var l, c, f, p, d, h, g = o! == a? "nextSibling": "previousSibling",
                            y = t.parentNode,
                            v = s && t.nodeName.toLowerCase (),
                            m =! u &&! s,
                            x =! 1;
                        if (y) {
                            if (o) {
                                tandis que (g) {
                                    p = t;
                                    tandis que (p = p [g])
                                        if (s? p.nodeName.toLowerCase () === v: 1 === p.nodeType) return! 1;
                                    h = g = "only" === e &&! h && "nextSibling"
                                }
                                retour! 0
                            }
                            if (h = [a? y.firstChild: y.lastChild], a && m) {
                                x = (d = (l = (c = (f = (p = y) [b] || (p [b] = {})) [p.uniqueID] || (f [p.uniqueID] = { })) [e] || []) [0] === T && l [1]) && l [2], p = d && y.childNodes [d];
                                tandis que (p = ++ d && p && p [g] || (x = d = 0) || h.pop ())
                                    si (1 === p.nodeType && ++ x && p === t) {
                                        c [e] = [T, d, x];
                                        Pause
                                    }
                            } sinon si (m && (x = d = (l = (c = (f = (p = t) [b] || (p [b] = {})) [p.IDunique] || (f [ p.uniqueID] = {})) [e] || []) [0] === T && l [1]),! 1 === x)
                                tandis que (p = ++ d && p && p [g] || (x = d = 0) || h.pop ())
                                    if ((s? p.nodeName.toLowerCase () === v: 1 === p.nodeType) && ++ x && (m && ((c = (f = p [b] || (p [b ] = {})) [p.uniqueID] || (f [p.uniqueID] = {})) [e] = [T, x]), p === t)) break;
                            retourne (x - = i) === r || x% r == 0 && x / r> = 0
                        }
                    }
                },
                PSEUDO: fonction (e, t) {
                    var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("pseudo non pris en charge:" + e);
                    retourner i [b]? i (t): i.longueur> 1? (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (function (e, n) {
                        var r, o = i (e, t),
                            a = o.longueur;
                        tandis que (a--) e [r = O (e, o [a])] =! (n [r] = o [a])
                    }): fonction (e) {
                        retourne i (e, 0, n)
                    }) : je
                }
            },
            pseudos: {
                pas: se (fonction (e) {
                    var t = [],
                        n = [],
                        r = s (par exemple, remplacer (B, "$ 1"));
                    retourne r [b]? se (fonction (e, t, n, i) {
                        var o, a = r (e, nul, i, []),
                            s = e.longueur;
                        tandis que (s -) (o = a [s]) && (e [s] =! (t [s] = o))
                    }): fonction (e, i, o) {
                        renvoie t [0] = e, r (t, nul, o, n), t [0] = nul,! n.pop ()
                    }
                }),
                a: se (fonction (e) {
                    fonction de retour (t) {
                        retourne oe (e, t) .length> 0
                    }
                }),
                contient: se (fonction (e) {
                    renvoie e = e.replace (Z, ee),
                        fonction (t) {
                            return (t.textContent || t.innerText || i (t)). indexOf (e)> -1
                        }
                }),
                lang: se (fonction (e) {
                    retourne U.test (e || "") || oe.error ("langue non prise en charge:" + e), e = e.replace (Z, ee) .toLowerCase (),
                        fonction (t) {
                            var n;
                            faire {
                                if (n = g? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLowerCase ()) === e || 0 === n.indexOf (e + "-")
                            } while ((t = t.parentNode) && 1 === t.nodeType);
                            retour! 1
                        }
                }),
                cible: fonction (t) {
                    var n = e.location && e.location.hash;
                    retourne n && n.slice (1) === t.id
                },
                racine: fonction (e) {
                    retourne e === h
                },
                focus: fonction (e) {
                    retourner e === d.activeElement && (! d.hasFocus || d.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)
                },
                activé: de (! 1),
                désactivé: de (! 0),
                vérifié: function (e) {
                    var t = e.nodeName.toLowerCase ();
                    retourne "input" === t && !! e.checked || "option" === t && !! e.selected
                },
                sélectionné: fonction (e) {
                    retourne e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected
                },
                vide: fonction (e) {
                    pour (e = e.firstChild; e; e = e.nextSibling)
                        if (e.nodeType <6) return! 1;
                    retour! 0
                },
                parent: function (e) {
                    return! r.pseudos.empty (e)
                },
                en-tête: function (e) {
                    retourne Y.test (e.nodeName)
                },
                entrée: fonction (e) {
                    retourne G.test (e.nodeName)
                },
                bouton: function (e) {
                    var t = e.nodeName.toLowerCase ();
                    retourne "input" === t && "button" === e.type || "bouton" === t
                },
                texte: fonction (e) {
                    var t;
                    retourne "input" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || "text" === t .toLowerCase ())
                },
                d'abord: il (function () {
                    retour [0]
                }),
                dernier: il (fonction (e, t) {
                    retour [t - 1]
                }),
                eq: he (fonction (e, t, n) {
                    renvoie [n <0? n + t: n]
                }),
                même: il (fonction (e, t) {
                    pour (var n = 0; n <t; n + = 2) e.push (n);
                    retour e
                }),
                impair: il (fonction (e, t) {
                    pour (var n = 1; n <t; n + = 2) e.push (n);
                    retour e
                }),
                lt: il (fonction (e, t, n) {
                    pour (var r = n <0? n + t: n; --r> = 0;) e.push (r);
                    retour e
                }),
                gt: il (fonction (e, t, n) {
                    pour (var r = n <0? n + t: n; ++ r <t;) e.push (r);
                    retour e
                })
            }
        }). pseudos.nth = r.pseudos.eq;
        pour (t dans {
                radio:! 0,
                case à cocher:! 0,
                fichier:! 0,
                mot de passe:! 0,
                image:! 0
            }) r.pseudos [t] = fe (t);
        pour (t dans {
                soumettre:! 0,
                réinitialiser:! 0
            }) r.pseudos [t] = pe (t);

        function ye () {}
        ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, a = oe.tokenize = function (e, t) {
            var n, i, o, a, s, u, l, c = k [e + ""];
            si (c) retourne t? 0: c.slice (0);
            s = e, u = [], l = r.preFilter;
            while (s) {
                n &&! (i = F.exec (s)) || (i && (s = s.slice (i [0] .length) || s), u.push (o = [])), n =! 1, (i = _.exec (s)) && ( n = i.shift (), o.push ({
                    valeur: n,
                    tapez: i [0] .replace (B, "")
                }), s = s.slice (n.length));
                pour (a dans r.filter)! (i = V [a] .exec (s)) || l [a] &&! (i = l [a] (i)) || (n = i.shift (), o.push ({
                    valeur: n,
                    type A,
                    correspond à: i
                }), s = s.slice (n.length));
                si (! n) pause
            }
            retour t? s.longueur: s? oe.error (e): k (e, u) .slice (0)
        };

        fonction ve (e) {
            for (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t] .value;
            retour r
        }

        fonction moi (e, t, n) {
            var r = t.dir,
                i = t.next,
                o = i || r,
                a = n && "parentNode" === o,
                s = C ++;
            retour t. premier? fonction (t, n, i) {
                tandis que (t = t [r])
                    if (1 === t.nodeType || a) renvoie e (t, n, i);
                retour! 1
            }: fonction (t, n, u) {
                var l, c, f, p = [T, s];
                si tu) {
                    tandis que (t = t [r])
                        if ((1 === t.nodeType || a) && e (t, n, u)) renvoie! 0
                } autre
                    tandis que (t = t [r])
                        si (1 === t.nodeType || a)
                            if (f = t [b] || (t [b] = {}), c = f [t.uniqueID] || (f [t.uniqueID] = {}), i && i === t. nodeName.toLowerCase ()) t = t [r] || t;
                            autre {
                                si ((l = c [o]) && l [0] === T && l [1] === s) return p [2] = l [2];
                                si (c [o] = p, p [2] = e (t, n, u)) retourne! 0
                            } retour! 1
            }
        }

        fonction xe (e) {
            retour e.length> 1? fonction (t, n, r) {
                var i = e.length;
                alors que je--)
                    if (! e [i] (t, n, r)) renvoie! 1;
                retour! 0
            }: e [0]
        }

        fonction be (e, t, n) {
            pour (var r = 0, i = t.longueur; r <i; r ++) oe (e, t [r], n);
            retour n
        }

        fonction nous (e, t, n, r, i) {
            pour (var o, a = [], s = 0, u = e.length, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s)));
            retourner un
        }

        fonction Te (e, t, n, r, i, o) {
            renvoie r &&! r [b] && (r = Te (r)), i &&! i [b] && (i = Te (i, o)), se (fonction (o, a, s, u) {
                var l, c, f, p = [],
                    d = [],
                    h = a.longueur,
                    g = o || be (t || "*", s.nodeType? [s]: s, []),
                    y =! e || ! o && t? g: nous (g, p, e, s, u),
                    v = n? i || (o? e: h || r)? []: a: y;
                si (n && n (y, v, s, u), r) {
                    l = we (v, d), r (l, [], s, u), c = l.longueur;
                    tandis que (c -) (f = l [c]) && (v [d [c]] =! (y [d [c]] = f))
                }
                if (o) {
                    si (i || e) {
                        si je) {
                            l = [], c = v.longueur;
                            tandis que (c -) (f = v [c]) && l.push (y [c] = f);
                            i (nul, v = [], l, u)
                        }
                        c = v.longueur;
                        tandis que (c -) (f = v [c]) && (l = i? O (o, f): p [c])> -1 && (o [l] =! (a [l] = f ))
                    }
                } sinon v = nous (v === a? v.splice (h, v.longueur): v), i? i (nul, a, v, u): L.apply (a, v)
            })
        }

        fonction Ce (e) {
            pour (var t, n, i, o = e.length, a = r.relative [e [0] .type], s = a || r.relative [""], u = a? 1: 0, c = moi (fonction (e) {
                    retourne e === t
                }, s,! 0), f = moi (fonction (e) {
                    retourne O (t, e)> -1
                }, s,! 0), p = [fonction (e, n, r) {
                    var i =! a && (r || n! == l) || ((t = n) .nodeType? c (e, n, r): f (e, n, r));
                    retourne t = nul, i
                }]; u <o; u ++)
                if (n = r.relatif [e [u] .type]) p = [me (xe (p), n)];
                autre {
                    if ((n = r.filter [e [u] .type] .apply (null, e [u] .matchs)) [b]) {
                        pour (i = ++ u; i <o; i ++)
                            if (r.relative [e [i] .type]) break;
                        renvoie Te (u> 1 && xe (p), u> 1 && ve (e.slice (0, u - 1) .concat ({
                            valeur: "" === e [u - 2] .type? "*": ""
                        })). replace (B, "$ 1"), n, u <i && Ce (e.slice (u, i)), i <o && Ce (e = e.slice (i)), i <o && ve (e))
                    }
                    p.pousser (n)
                } retourne xe (p)
        }

        fonction Ee (e, t) {
            var n = t.longueur> 0,
                i = e.longueur> 0,
                o = fonction (o, a, s, u, c) {
                    var f, h, y, v = 0,
                        m = "0",
                        x = o && [],
                        b = [],
                        w = l,
                        C = o || i && r.find.TAG ("*", c),
                        E = T + = nul == w? 1: Math.random () || .1,
                        k = longueur C.;
                    pour (c && (l = a === d || a || c); m! == k && null! = (f = C [m]); m ++) {
                        si si) {
                            h = 0, a || f.ownerDocument === d || (p (f), s =! g);
                            tandis que (y = e [h ++])
                                si (y (f, a || d, s)) {
                                    u.push (f);
                                    Pause
                                } c && (T = E)
                        }
                        n && ((f =! y && f) && v--, o && x.push (f))
                    }
                    si (v + = m, n && m! == v) {
                        h = 0;
                        tandis que (y = t [h ++]) y (x, b, a, s);
                        if (o) {
                            si (v> 0)
                                tandis que (m--) x [m] || b [m] || (b [m] = j.call (u));
                            b = nous (b)
                        }
                        L.apply (u, b), c &&! O && b.length> 0 && v + t.length> 1 && oe.uniqueSort (u)
                    }
                    renvoie c && (T = E, l = w), x
                };
            retourner n? se (o): o
        }
        retourne s = oe.compile = function (e, t) {
            var n, r = [],
                i = [],
                o = S [e + ""];
            si (! o) {
                t || (t = a (e)), n = t.longueur;
                tandis que (n -) (o = Ce (t [n])) [b]? r.push (o): i.push (o);
                (o = S (e, Ee (i, r))). sélecteur = e
            }
            retour o
        }, u = oe.select = fonction (e, t, n, i) {
            var o, u, l, c, f, p = "fonction" == type de e && e,
                d =! i && a (e = p.selector || e);
            si (n = n || [], 1 === d.longueur) {
                if ((u = d [0] = d [0] .slice (0)). length> 2 && "ID" === (l = u [0]). type && 9 === t.nodeType && g && r.relative [u [1] .type]) {
                    if (! (t = (r.find.ID (l.matches [0] .replace (Z, ee), t) || []) [0])) return n;
                    p && (t = t.parentNode), e = e.slice (u.shift (). value.length)
                }
                o = V.needsContext.test (e)? 0: u.length;
                tandis que (o--) {
                    if (l = u [o], r.relative [c = l.type]) break;
                    if ((f = r.find [c]) && (i = f (l.matches [0] .replace (Z, ee), K.test (u [0] .type) && ge (t.parentNode) || t))) {
                        if (u.splice (o, 1),! (e = i.length && ve (u))) renvoie L.apply (n, i), n;
                        Pause
                    }
                }
            }
            return (p || s (e, d)) (i, t,! g, n,! t || K.test (e) && ge (t.parentNode) || t), n
        }, n.sortStable = b.split (""). sort (D) .join ("") === b, n.detectDuplicates = !! f, p (), n.sortDetached = ue (function (e ) {
            return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))
        }), ue (fonction (e) {
            return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")
        }) || le ("type | href | hauteur | largeur", fonction (e, t, n) {
            if (! n) renvoie e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)
        }), n.attributs && ue (fonction (e) {
            return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), "" === e.firstChild.getAttribute ("value")
        }) || le ("valeur", fonction (e, t, n) {
            if (! n && "input" === e.nodeName.toLowerCase ()) renvoie e.defaultValue
        }), ue (fonction (e) {
            return null == e.getAttribute ("disabled")
        }) || le (P, fonction (e, t, n) {
            var r;
            si (! n) renvoie! 0 === e [t]? t.toLowerCase (): (r = e.getAttributeNode (t)) && r.specified? r.value: null
        }), oe
    } (e);
    w.find = E, w.expr = E.selectors, w.expr [":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w .isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape;
    var k = fonction (e, t, n) {
            var r = [],
                i = vide 0! == n;
            tandis que ((e = e [t]) && 9! == e.nodeType)
                if (1 === e.nodeType) {
                    if (i && w (e) .is (n)) break;
                    r.push (e)
                } retourne r
        },
        S = fonction (e, t) {
            pour (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e);
            retour n
        },
        D = w.expr.match.needsContext;

    fonction N (e, t) {
        retourne e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()
    }
    var A = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (? : <\ / \ 1> |) $ / i;

    fonction j (e, t, n) {
        retourne g (t)? w.grep (e, fonction (e, r) {
            retour !! t.call (e, r, e)! == n
        }): t.nodeType? w.grep (e, fonction (e) {
            renvoie e === t! == n
        }): "chaîne"! = typeof t? w.grep (e, fonction (e) {
            renvoie u.call (t, e)> -1! == n
        }): w.filtre (t, e, n)
    }
    w.filtre = fonction (e, t, n) {
        var r = t [0];
        renvoie n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? w.find.matchesSelector (r, e)? [r]: []: w.find.matches (e, w.grep (t, fonction (e) {
            retourne 1 === e.nodeType
        }))
    }, w.fn.extend ({
        trouver: function (e) {
            var t, n, r = this.length,
                i = ceci;
            if ("string"! = typeof e) renvoie this.pushStack (w (e) .filter (function () {
                pour (t = 0; t <r; t ++)
                    if (w.contains (i [t], this)) return! 0
            }));
            pour (n = this.pushStack ([]), t = 0; t <r; t ++) w.find (e, i [t], n);
            retourne r> 1? w.uniqueSort (n): n
        },
        filtre: fonction (e) {
            retourne this.pushStack (j (this, e || [],! 1))
        },
        pas: function (e) {
            retourne this.pushStack (j (this, e || [],! 0))
        },
        est: function (e) {
            return !! j (this, "string" == typeof e && D.test (e)? w (e): e || [],! 1) .length
        }
    });
    var q, L = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /;
    (w.fn.init = fonction (e, t, n) {
        var i, o;
        if (! e) renvoie ceci;
        si (n = n || q, "chaîne" == type de e) {
            if (! (i = "<" === e [0] && ">" === e [e.length - 1] && e.length> = 3? [null, e, null]: L.exec (e)) ||! i [1] && t) retour! t || t.jquery? (t || n) .find (e): ce.constructeur (t) .find (e);
            si (i [1]) {
                if (t = t instanceof w? t [0]: t, w.merge (this, w.parseHTML (i [1], t && t.nodeType? t.ownerDocument || t: r,! 0)), A.test (i [1]) && w.isPlainObject (t))
                    pour (i dans t) g (ce [i])? this [i] (t [i]): this.attr (i, t [i]);
                retourne ça
            }
            return (o = r.getElementById (i [2])) && (this [0] = o, this.length = 1), this
        }
        retourner e.nodeType? (this [0] = e, this.length = 1, this): g (e)? void 0! == n. prêt? n.ready (e): e (w): w.makeArray (e, ceci)
    }). prototype = w.fn, q = w (r);
    var H = / ^ (?: parents | prev (?: Jusqu'à | Tout)) /,
        O = {
            enfants:! 0,
            contenu:! 0,
            suivant:! 0,
            prev:! 0
        };
    w.fn.extend ({
        has: function (e) {
            var t = w (e, ceci),
                n = t.longueur;
            retourne this.filter (function () {
                pour (var e = 0; e <n; e ++)
                    if (w.contains (this, t [e])) return! 0
            })
        },
        le plus proche: function (e, t) {
            var n, r = 0,
                i = this.length,
                o = [],
                a = "chaîne"! = type de e && w (e);
            si (! D. test (e))
                pour (; r <i; r ++)
                    pour (n = this [r]; n && n! == t; n = n.parentNode)
                        if (n.nodeType <11 && (a? a.index (n)> -1: 1 === n.nodeType && w.find.matchesSelector (n, e))) {
                            o.push (n);
                            Pause
                        } renvoie this.pushStack (o.length> 1? w.uniqueSort (o): o)
        },
        index: fonction (e) {
            retour e? "string" == typeof e? u.call (w (e), this [0]): u.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1
        },
        ajouter: fonction (e, t) {
            renvoyer this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t))))
        },
        addBack: function (e) {
            renvoie this.add (null == e? this.prevObject: this.prevObject.filter (e))
        }
    });

    fonction P (e, t) {
        while ((e = e [t]) && 1! == e.nodeType);
        retour e
    }
    avec chaque ({
        parent: function (e) {
            var t = e.parentNode;
            retourne t && 11! == t.nodeType? t: nul
        },
        parents: function (e) {
            retourne k (e, "parentNode")
        },
        parentsJusqu'à: function (e, t, n) {
            renvoie k (e, "parentNode", n)
        },
        suivant: function (e) {
            retourne P (e, "nextSibling")
        },
        prev: function (e) {
            return P (e, "previousSibling")
        },
        nextAll: function (e) {
            retourne k (e, "nextSibling")
        },
        prevAll: function (e) {
            retourne k (e, "previousSibling")
        },
        suivantUntil: function (e, t, n) {
            retourne k (e, "nextSibling", n)
        },
        prevUntil: function (e, t, n) {
            retourne k (e, "previousSibling", n)
        },
        frères et sœurs: function (e) {
            retourne S ((e.parentNode || {}). firstChild, e)
        },
        enfants: function (e) {
            retourne S (e.firstChild)
        },
        contenu: function (e) {
            retourne N (e, "iframe")? e.contentDocument: (N (e, "template") && (e = e.content || e), w.merge ([], e.childNodes))
        }
    }, fonction (e, t) {
        w.fn [e] = fonction (n, r) {
            var i = w.map (ceci, t, n);
            retourne "Jusqu'à"! == e.slice (-5) && (r = n), r && "string" == typeof r && (i = w.filter (r, i)), this.length> 1 && (O [e] || w.uniqueSort (i), H.test (e) && i.reverse ()), this.pushStack (i)
        }
    });
    var M = / [^ \ x20 \ t \ r \ n \ f] + / g;

    fonction R (e) {
        var t = {};
        return w.each (e.match (M) || [], fonction (e, n) {
            t [n] =! 0
        }), t
    }
    w.Callbacks = fonction (e) {
        e = "chaîne" == type de e? R (e): w.extend ({}, e);
        var t, n, r, i, o = [],
            a = [],
            s = -1,
            u = fonction () {
                pour (i = i || e.once, r = t =! 0; a.length; s = -1) {
                    n = a.shift ();
                    while (++ s <o.length)! 1 === o [s] .apply (n [0], n [1]) && e.stopOnFalse && (s = o.length, n =! 1)
                }
                e.memory || (n =! 1), t =! 1, i && (o = n? []: "")
            },
            l = {
                ajouter: function () {
                    retourne o && (n &&! t && (s = o.length - 1, a.push (n)), function t (n) {
                        w.each (n, fonction (n, r) {
                            g (r)? e.unique && l.has (r) || o.push (r): r && r.length && "string"! == x (r) && t (r)
                        })
                    } (arguments), n &&! t && u ()), ce
                },
                supprimer: function () {
                    retourne w.each (arguments, fonction (e, t) {
                        var n;
                        tandis que ((n = w.inArray (t, o, n))> -1) o.splice (n, 1), n ​​<= s && s--
                    }), ce
                },
                has: function (e) {
                    retour e? w.inArray (e, o)> -1: o.length> 0
                },
                vide: function () {
                    retourne o && (o = []), ceci
                },
                désactiver: function () {
                    renvoie i = a = [], o = n = "", ceci
                },
                désactivé: function () {
                    retour! o
                },
                lock: function () {
                    retourne i = a = [], n || t || (o = n = ""), ceci
                },
                verrouillé: function () {
                    retour !! je
                },
                fireWith: fonction (e, n) {
                    retourne i || (n = [e, (n = n || []). slice? n.slice (): n], a.push (n), t || u ()), this
                },
                feu: function () {
                    retourne l.fire Avec (this, arguments), this
                },
                déclenché: function () {
                    retour !! r
                }
            };
        retour l
    };

    fonction I (e) {
        retour e
    }

    fonction W (e) {
        jeter e
    }

    fonction $ (e, t, n, r) {
        var i;
        essayez {
            e && g (i = e.promise)? i.call (e) .done (t) .fail (n): e && g (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))
        } catch (e) {
            n.apply (void 0, [e])
        }
    }
    w.extend ({
        Différé: function (t) {
            var n = [
                    ["notifier", "progression", w.Callbacks ("mémoire"), w.Callbacks ("mémoire"), 2],
                    ["résoudre", "terminé", w.Callbacks ("une fois mémoire"), w.Callbacks ("une fois mémoire"), 0, "résolu"],
                    ["rejeter", "échouer", w.Callbacks ("une fois mémoire"), w.Callbacks ("une fois mémoire"), 1, "rejeté"]
                ],
                r = "en attente",
                i = {
                    fonction d'état () {
                        retour r
                    },
                    toujours: function () {
                        return o.done (arguments) .fail (arguments), this
                    },
                    "catch": function (e) {
                        return i.then (nul, e)
                    },
                    pipe: function () {
                        var e = arguments;
                        return w.Deferred (fonction (t) {
                            w.each (n, fonction (n, r) {
                                var i = g (e [r [4]]) && e [r [4]];
                                o [r [1]] (fonction () {
                                    var e = i && i.apply (ceci, arguments);
                                    e && g (e.promise)? e.promise (). progress (t.notify) .done (t.resolve) .fail (t.reject): t [r [0] + "With"] (this, i? [e]: arguments)
                                })
                            }), e = nul
                        }).promettre()
                    },
                    alors: function (t, r, i) {
                        var o = 0;

                        fonction a (t, n, r, i) {
                            fonction de retour () {
                                var s = ceci,
                                    u = arguments,
                                    l = fonction () {
                                        var e, l;
                                        si (! (t <o)) {
                                            if ((e = r.apply (s, u)) === n.promise ()) throw new TypeError ("Auto-résolution Thenable");
                                            l = e && ("objet" == type de e || "fonction" == type de e) && e. alors, g (l)? je ? l.call (e, a (o, n, I, i), a (o, n, W, i)): (o ++, l.call (e, a (o, n, I, i), a (o, n, W, i), a (o, n, I, n.notifyWith))): (r! == I && (s = vide 0, u = [e]), (i || n .resolveWith) (s, u))
                                        }
                                    },
                                    c = i? l: fonction () {
                                        essayez {
                                            l ()
                                        } catch (e) {
                                            w.Deferred.exceptionHook && w.Deferred.exceptionHook (e, c.stackTrace), t + 1> = o && (r! == W && (s = void 0, u = [e]), n.rejectWith ( s, u))
                                        }
                                    };
                                t? c (): (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))
                            }
                        }
                        return w.Deferred (fonction (e) {
                            n [0] [3] .add (a (0, e, g (i)? i: I, e.notifyWith)), n [1] [3] .add (a (0, e, g (t )? t: I)), n [2] [3] .add (a (0, e, g (r)? r: W))
                        }).promettre()
                    },
                    promesse: fonction (e) {
                        renvoie null! = e? w.extend (e, i): i
                    }
                },
                o = {};
            retourne w.each (n, fonction (e, t) {
                var a = t [2],
                    s = t [5];
                i [t [1]] = a.add, s && a.add (fonction () {
                    r = s
                }, n [3 - e] [2] .disable, n [3 - e] [3] .disable, n [0] [2] .lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = fonction () {
                    return o [t [0] + "With"] (this === o? void 0: this, arguments), this
                }, o [t [0] + "With"] = a.fireWith
            }), i.promise (o), t && t.call (o, o), o
        },
        quand: function (e) {
            var t = arguments.length,
                n = t,
                r = tableau (n),
                i = o.call (arguments),
                a = w.Deferred (),
                s = fonction (e) {
                    fonction de retour (n) {
                        r [e] = ceci, i [e] = arguments.longueur> 1? o.call (arguments): n, --t || a.resolveWith (r, i)
                    }
                };
            if (t <= 1 && ($ (e, a.done (s (n)). résoudre, a.reject,! t), "en attente" === a.state () || g (i [n ] && i [n] .then))) return a.then ();
            tandis que (n--) $ (i [n], s (n), a.reject);
            retourne une.promise ()
        }
    });
    var B = / ^ (Eval | Interne | Plage | Référence | Syntaxe | Type | URI) Erreur $ /;
    w.Deferred.exceptionHook = fonction (t, n) {
        e.console && e.console.warn && t && B.test (t.name) && e.console.warn ("jQuery.Deferred exception:" + t.message, t.stack, n)
    }, w.readyException = fonction (t) {
        e.setTimeout (fonction () {
            jeter t
        })
    };
    var F = w.Deferred ();
    w.fn.ready = fonction (e) {
        retourne F.then (e) ["catch"] (function (e) {
            w.readyException (e)
        }), ce
    }, w.extend ({
        isReady:! 1,
        readyWait: 1,
        prêt: function (e) {
            (! 0 === e? --W.readyWait: w.isReady) || (w.isReady =! 0,! 0! == e && --w.readyWait> 0 || F.resolveWith (r, [w]))
        }
    }), w.ready.then = F.then;

    fonction _() {
        r.removeEventListener ("DOMContentLoaded", _), e.removeEventListener ("charger", _), w.ready ()
    }
    "complete" === r.readyState || "chargement"! == r.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready): (r.addEventListener ("DOMContentLoaded", _), e.addEventListener ("load", _));
    var z = fonction (e, t, n, r, i, o, a) {
            var s = 0,
                u = e.longueur,
                l = nul == n;
            if ("objet" === x (n)) {
                i =! 0;
                pour (s dans n) z (e, t, s, n [s],! 0, o, a)
            } else if (void 0! == r && (i =! 0, g (r) || (a =! 0), l && (a? (t.call (e, r), t = null): (l = t, t = fonction (e, t, n) {
                    retourne l.call (w (e), n)
                })), t))
                pour (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n)));
            retourner je? e: l? t.call (e): u? t (e [0], n): o
        },
        X = / ^ - ms- /,
        U = / - ([az]) / g;

    fonction V (e, t) {
        retourne t.toUpperCase ()
    }

    fonction G (e) {
        return e.replace (X, "ms -"). replace (U, V)
    }
    var Y = fonction (e) {
        retourne 1 === e.nodeType || 9 === e.nodeType || ! + e.nodeType
    };

    fonction Q () {
        this.expando = w.expando + Q.uid ++
    }
    Q.uid = 1, Q.prototype = {
        cache: fonction (e) {
            var t = e [this.expando];
            retour t || (t = {}, Y (e) && (e.nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {
                valeur: t,
                configurable:! 0
            }))), t
        },
        set: fonction (e, t, n) {
            var r, i = this.cache (e);
            if ("string" == typeof t) i [G (t)] = n;
            autre
                pour (r dans t) i [G (r)] = t [r];
            retourne je
        },
        get: function (e, t) {
            retourne vide 0 === t? this.cache (e): e [this.expando] && e [this.expando] [G (t)]
        },
        accès: fonction (e, t, n) {
            retourne vide 0 === t || t && "chaîne" == typeof t && void 0 === n? this.get (e, t): (this.set (e, t, n), void 0! == n? n: t)
        },
        supprimer: fonction (e, t) {
            var n, r = e [this.expando];
            if (void 0! == r) {
                si (vide 0! == t) {
                    n = (t = Array.isArray (t)? t.map (G): (t = G (t)) dans r? [t]: t.match (M) || []). length;
                    tandis que (n--) supprime r [t [n]]
                } (void 0 === t || w.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: supprime e [this.expando])
            }
        },
        hasData: function (e) {
            var t = e [this.expando];
            return void 0! == t &&! w.isEmptyObject (t)
        }
    };
    var J = nouveau Q,
        K = nouveau Q,
        Z = / ^ (?: \ {[\ W \ W] * \} | \ [[[\ w \ W] * \]) $ /,
        ee = / [AZ] / g;

    fonction te (e) {
        retourne "vrai" === e || "faux"! == e && ("null" === e? null: e === + e + ""? + e: Z.test (e)? JSON.parse (e): e)
    }

    fonction ne (e, t, n) {
        var r;
        if (void 0 === n && 1 === e.nodeType)
            if (r = "data-" + t.replace (ee, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {
                essayez {
                    n = te (n)
                } catch (e) {}
                K.set (e, t, n)
            } sinon n = vide 0;
        retour n
    }
    w.extend ({
        hasData: function (e) {
            retour K.hasData (e) || J.hasData (e)
        },
        données: fonction (e, t, n) {
            retourne K.access (e, t, n)
        },
        removeData: fonction (e, t) {
            K. supprimer (e, t)
        },
        _data: fonction (e, t, n) {
            retourne J.access (e, t, n)
        },
        _removeData: fonction (e, t) {
            J.remove (e, t)
        }
    }), w.fn.extend ({
        données: fonction (e, t) {
            var n, r, i, o = ceci [0],
                a = o && o.attributs;
            if (void 0 === e) {
                if (this.length && (i = K.get (o), 1 === o.nodeType &&! J.get (o, "hasDataAttrs"))) {
                    n = a.longueur;
                    while (n--) a [n] && 0 === (r = a [n] .name) .indexOf ("data-") && (r = G (r.slice (5)), ne (o , r, i [r]));
                    J.set (o, "hasDataAttrs",! 0)
                }
                retourne je
            }
            retourne "objet" == typeof e? this.each (fonction () {
                K.set (ceci, e)
            }): z (ceci, fonction (t) {
                var n;
                if (o && void 0 === t) {
                    if (void 0! == (n = K.get (o, e))) renvoie n;
                    if (void 0! == (n = ne (o, e))) renvoie n
                } sinon this.each (function () {
                    K.set (ceci, e, t)
                })
            }, null, t, arguments.length> 1, null,! 0)
        },
        removeData: function (e) {
            retourne this.each (function () {
                K.remove (ceci, e)
            })
        }
    }), w.extend ({
        file d'attente: fonction (e, t, n) {
            var r;
            if (e) return t = (t || "fx") + "queue", r = J.get (e, t), n && (! r || Array.isArray (n)? r = J.access (e, t, w.makeArray (n)): r.push (n)), r || []
        },
        dequeue: function (e, t) {
            t = t || "fx";
            var n = w.queue (e, t),
                r = n.longueur,
                i = n.shift (),
                o = w._queueHooks (e, t),
                a = fonction () {
                    w.de file d'attente (e, t)
                };
            "inprogress" === i && (i = n.shift (), r--), i && ("fx" === t && n.unshift ("inprogress"), supprimer o.stop, i.call (e, a, o)),! r && o && o.empty.fire ()
        },
        _queueHooks: fonction (e, t) {
            var n = t + "queueHooks";
            retourne J.get (e, n) || J.access (e, n, {
                vide: w.Callbacks ("mémoire unique"). add (function () {
                    J.remove (e, [t + "file d'attente", n])
                })
            })
        }
    }), w.fn.extend ({
        file d'attente: fonction (e, t) {
            var n = 2;
            renvoie "string"! = typeof e && (t = e, e = "fx", n--), arguments.length <n? w.queue (this [0], e): void 0 === t? ceci: this.each (function () {
                var n = w.queue (ceci, e, t);
                w._queueHooks (this, e), "fx" === e && "inprogress"! == n [0] && w.dequeue (this, e)
            })
        },
        dequeue: function (e) {
            retourne this.each (function () {
                w.de file d'attente (ceci, e)
            })
        },
        clearQueue: fonction (e) {
            renvoie this.queue (e || "fx", [])
        },
        promesse: fonction (e, t) {
            var n, r = 1,
                i = w. différé (),
                o = ceci,
                a = this.length,
                s = fonction () {
                    --r || i.resolveWith (o, [o])
                };
            "chaîne"! = type de e && (t = e, e = vide 0), e = e || "fx";
            while (a -) (n = J.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add (s));
            retourne s (), i.promise (t)
        }
    });
    var re = /[+- </font>?(?:\d*\.|)\d+(?:[eE[+- </font>?\d+|)/.source,
        ie = new RegExp ("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $", "i"),
        oe = ["Haut", "Droite", "Bas", "Gauche"],
        ae = fonction (e, t) {
            retourne "aucun" === (e = t || e) .style.display || "" === e.style.display && w.contains (e.ownerDocument, e) && "none" === w.css (e, "display")
        },
        se = fonction (e, t, n, r) {
            var i, o, a = {};
            pour (o en t) a [o] = e.style [o], e.style [o] = t [o];
            i = n.appliquer (e, r || []);
            pour (o en t) e.style [o] = a [o];
            retourne je
        };

    fonction ue (e, t, n, r) {
        var i, o, a = 20,
            s = r? fonction () {
                retour r.cur ()
            } : fonction () {
                retourne w.css (e, t, "")
            },
            u = s (),
            l = n && n [3] || (w.cssNumber [t]? "": "px"),
            c = (w.cssNumber [t] || "px"! == l && + u) && ie.exec (w.css (e, t));
        si (c && c [3]! == l) {
            u / = 2, l = l || c [3], c = + u || 1;
            tandis que (a--) w.style (e, t, c + l), (1 - o) * (1 - (o = s () / u || .5)) <= 0 && (a = 0 ), c / = o;
            c * = 2, w.style (e, t, c + l), n = n || []
        }
        renvoie n && (c = + c || + u || 0, i = n [1]? c + (n [1] + 1) * n [2]: + n [2], r && (r. unité = l, r.start = c, r.end = i)), i
    }
    var le = {};

    fonction ce (e) {
        var t, n = e.ownerDocument,
            r = e.nodeName,
            i = le [r];
        retourne i || (t = n.body.appendChild (n.createElement (r)), i = w.css (t, "display"), t.parentNode.removeChild (t), "none" === i && (i = "bloc"), le [r] = i, i)
    }

    fonction fe (e, t) {
        pour (var n, r, i = [], o = 0, a = e.length; o <a; o ++) (r = e [o]). style && (n = r.style.display, t? ("aucun" === n && (i [o] = J.get (r, "affichage") || nul, i [o] || (r.style.display = "")), "" = == r.style.display && ae (r) && (i [o] = ce (r))): "aucun"! == n && (i [o] = "aucun", Js et (r, " affichage ", n)));
        pour (o = 0; o <a; o ++) null! = i [o] && (e [o] .style.display = i [o]);
        retour e
    }
    w.fn.extend ({
        afficher: function () {
            retourne fe (ceci,! 0)
        },
        cacher: function () {
            retourne fe (ça)
        },
        bascule: function (e) {
            retourne "booléen" == typeof e? e? this.show (): this.hide (): this.each (fonction () {
                ae (ça)? w (ceci) .show (): w (ceci) .hide ()
            })
        }
    });
    var pe = / ^ (?: case à cocher | radio) $ / i,
        de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i,
        he = / ^ $ | ^ module $ | \ / (?: java | ecma) script / i,
        ge = {
            option: [1, "<select multiple = 'multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table> <colgroup>", "</colgroup> </table>"],
            tr: [2, "<table> <tbody>", "</tbody> </table>"],
            td: [3, "<table> <tbody> <tr>", "</tr> </tbody> </table>"],
            _par défaut: [0, "", ""]
        };
    ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;

    fonction ye (e, t) {
        var n;
        return n = "indéfini"! = typeof e.getElementsByTagName? e.getElementsByTagName (t || "*"): "undefined"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*"): [], vide 0 === t || t && N (e, t)? w.merge ([e], n): n
    }

    fonction ve (e, t) {
        pour (var n = 0, r = e.length; n <r; n ++) J.set (e [n], "globalEval",! t || J.get (t [n], "globalEval"))
    }
    var me = / <| & #? \ w +; /;

    fonction xe (e, t, n, r, i) {
        pour (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; d <h; d ++)
            si ((o = e [d]) || 0 === o)
                if ("objet" === x (o)) w.merge (p, o.nodeType? [o]: o);
                sinon si (me.test (o)) {
            a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + w.htmlPrefilter (o) + u [2], c = u [0];
            tandis que (c--) a = a.lastChild;
            w.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""
        } else p.push (t.createTextNode (o));
        f.textContent = "", d = 0;
        tandis que (o = p [d ++])
            if (r && w.inArray (o, r)> -1) i && i.push (o);
            sinon si (l = w.contains (o.ownerDocument, o), a = ye (f.appendChild (o), "script"), l && ve (a), n) {
            c = 0;
            while (o = a [c ++]) he.test (o.type || "") && n.push (o)
        }
        retour f
    }! fonction () {
        var e = r.createDocumentFragment (). appendChild (r.createElement ("div")),
            t = r.createElement ("entrée");
        t.setAttribute ("type", "radio"), t.setAttribute ("vérifié", "vérifié"), t.setAttribute ("nom", "t"), e.appendChild (t), h.checkClone = e.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, e.innerHTML = "<textarea> x </textarea>", h.noCloneChecked = !! e.cloneNode (! 0) .lastChild.defaultValue
    } ();
    var be = r.documentElement,
        nous = / ^ clé /,
        Te = / ^ (?: souris | pointeur | menu contextuel | glisser | déposer) | cliquer /,
        Ce = /^([^. </font>*)(?:\.(.+)|)/;

    function Ee () {
        retour! 0
    }

    function ke () {
        retour! 1
    }

    function Se () {
        essayez {
            retourne r.activeElement
        } catch (e) {}
    }

    fonction De (e, t, n, r, i, o) {
        var a, s;
        if ("objet" == typeof t) {
            "chaîne"! = type de n && (r = r || n, n = vide 0);
            pour (s en t) De (e, s, n, r, t [s], o);
            retour e
        }
        if (null == r && null == i? (i = n, r = n = void 0): null == i && ("string" == typeof n? (i = r, r = void 0): (i = r, r = n, n = vide 0)),! 1 === i) i = ke;
        sinon si (! i) retourne e;
        retourne 1 === o && (a = i, (i = fonction (e) {
            retourne w (). off (e), a.apply (this, arguments)
        }). guid = a.guid || (a.guid = w.guid ++)), e.each (fonction () {
            w.event.add (ceci, t, i, r, n)
        })
    }
    w.event = {
        global: {},
        ajouter: fonction (e, t, n, r, i) {
            var o, a, s, u, l, c, f, p, d, h, g, y = J.get (e);
            if (y) {
                n.handler && (n = (o = n) .handler, i = o.selector), i && w.find.matchesSelector (be, i), n.guid || (n.guid = w.guid ++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function (t) {
                    renvoie "undefined"! = typeof w && w.event.triggered! == t.type? w.event.dispatch.apply (e, arguments): void 0
                }), l = (t = (t || "") .match (M) || [""]). longueur;
                tandis que (l--) d = g = (s = Ce.exec (t [l]) || []) [1], h = (s [2] || "") .split (".") .sort (), d && (f = w.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = w.event.special [d] || {}, c = w.extend ({
                    type: d,
                    origType: g,
                    données: r,
                    gestionnaire: n,
                    guid: n.guid,
                    sélecteur: i,
                    needsContext: i && w.expr.match.needsContext.test (i),
                    espace de noms: h.join (".")
                }, o), (p = u [d]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (e, r, h, a) || e.addEventListener && e.addEventListener ( d, a)), f.add && (f.add.call (e, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p.delegateCount ++, 0, c): p.push (c), w.event.global [d] =! 0)
            }
        },
        supprimer: fonction (e, t, n, r, i) {
            var o, a, s, u, l, c, f, p, d, h, g, y = J.hasData (e) && J.get (e);
            if (y && (u = y.events)) {
                l = (t = (t || "") .match (M) || [""]). longueur;
                tandis que (l--)
                    if (s = Ce.exec (t [l]) || [], d = g = s [1], h = (s [2] || "") .split ("."). sort () , ré) {
                        f = w.event.special [d] || {}, p = u [d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") + "(\\. | $) "), a = o = p.longueur;
                        tandis que (o--) c = p [o],! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! c.selector) || (p.splice (o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call (e, c));
                        a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, y.handle) || w.removeEvent (e, d, y.handle), supprime u [d ])
                    } autre
                        pour (d dans u) w.event.remove (e, d + t [l], n, r,! 0);
                w.isEmptyObject (u) && J.remove (e, "gérer les événements")
            }
        },
        dispatch: function (e) {
            var t = w.event.fix (e),
                n, r, i, o, a, s, u = nouveau tableau (arguments.length),
                l = (J.get (ceci, "événements") || {}) [t.type] || [],
                c = w.event.special [t.type] || {};
            pour (u [0] = t, n = 1; n <arguments.length; n ++) u [n] = arguments [n];
            if (t.delegateTarget = this,! c.preDispatch ||! 1! == c.preDispatch.call (this, t)) {
                s = w.event.handlers.call (this, t, l), n = 0;
                while ((o = s [n ++]) &&! t.isPropagationStopped ()) {
                    t.currentTarget = o.elem, r = 0;
                    while ((a = o.handlers [r ++]) &&! t.isImmediatePropagationStopped ()) t.rnamespace &&! t.rnamespace.test (a.namespace) || (t.handleObj = a, t.data = a.data, void 0! == (i = ((w.event.special [a.origType] || {}). handle || a.handler) .apply (o.elem, u)) &&! 1 === (t.result = i) && (t.preventDefault (), t.stopPropagation ()))
                }
                retourne c.postDispatch && c.postDispatch.call (this, t), t.result
            }
        },
        gestionnaires: function (e, t) {
            var n, r, i, o, a, s = [],
                u = t.delegateCount,
                l = e.target;
            if (u && l.nodeType &&! ("clic" === e.type && e.button> = 1))
                pour (; l! == this; l = l.parentNode || this)
                    if (1 === l.nodeType && ("clic"! == e.type ||! 0! == l.disabled)) {
                        pour (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). selector + ""] && (a [i ] = r.needsContext? w (i, this) .index (l)> -1: w.find (i, this, null, [l]). length), a [i] && o.push (r) ;
                        o.length && s.push ({
                            elem: l,
                            gestionnaires: o
                        })
                    } renvoie l = this, u <t.length && s.push ({
                elem: l,
                gestionnaires: t.slice (u)
            }), s
        },
        addProp: fonction (e, t) {
            Object.defineProperty (w.Event.prototype, e, {
                énumérable:! 0,
                configurable:! 0,
                obtenir: g (t)? fonction () {
                    if (this.originalEvent) retourne t (this.originalEvent)
                } : fonction () {
                    if (this.originalEvent) renvoie this.originalEvent [e]
                },
                set: function (t) {
                    Object.defineProperty (this, e, {
                        énumérable:! 0,
                        configurable:! 0,
                        inscriptible:! 0,
                        valeur: t
                    })
                }
            })
        },
        correction: fonction (e) {
            retourner e [w.expando]? e: nouveau w.Event (e)
        },
        spécial: {
            charge: {
                noBubble:! 0
            },
            concentrer: {
                déclencheur: function () {
                    if (this! == Se () && this.focus) renvoie this.focus (),! 1
                },
                delegateType: "focusin"
            },
            flou: {
                déclencheur: function () {
                    if (this === Se () && this.blur) renvoie this.blur (),! 1
                },
                delegateType: "focusout"
            },
            Cliquez sur: {
                déclencheur: function () {
                    if ("checkbox" === this.type && this.click && N (this, "input")) return this.click (),! 1
                },
                _par défaut: function (e) {
                    retourne N (e.target, "a")
                }
            },
            avant le déchargement: {
                postDispatch: function (e) {
                    void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                }
            }
        }
    }, w.removeEvent = fonction (e, t, n) {
        e.removeEventListener && e.removeEventListener (t, n)
    }, w.Event = fonction (e, t) {
        if (! (this instanceof w.Event)) return new w.Event (e, t);
        e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? Ee: ke, this.target = e.target && 3 === e.target.nodeType? e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && w .extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [w.expando] =! 0
    }, w.Event.prototype = {
        constructeur: w.Event,
        isDefaultPrevented: ke,
        isPropagationStopped: ke,
        isImmediatePropagationStopped: ke,
        isSimulé:! 1,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = Ee, e &&! this.isSimulated && e.preventDefault ()
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = Ee, e &&! this.isSimulated && e.stopPropagation ()
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = Ee, e &&! this.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()
        }
    }, avec chaque ({
        altKey:! 0,
        bulles:! 0,
        annulable:! 0,
        changéTouches:! 0,
        ctrlKey:! 0,
        détail:! 0,
        eventPhase:! 0,
        metaKey:! 0,
        pageX:! 0,
        pageY:! 0,
        shiftKey:! 0,
        vue:! 0,
        "char":! 0,
        charCode:! 0,
        clé:! 0,
        keyCode:! 0,
        bouton:! 0,
        boutons:! 0,
        clientX:! 0,
        clientY:! 0,
        offsetX:! 0,
        offsetY:! 0,
        pointerId:! 0,
        pointerType:! 0,
        screenX:! 0,
        screenY:! 0,
        targetTouches:! 0,
        toElement:! 0,
        touche:! 0,
        qui: function (e) {
            var t = bouton e.;
            renvoie null == e.which && we.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Te.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e. Qui
        }
    }, w.event.addProp), w.each ({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, fonction (e, t) {
        w.event.special [e] = {
            delegateType: t,
            bindType: t,
            handle: function (e) {
                var n, r = ceci,
                    i = e.relatedTarget,
                    o = e.handleObj;
                renvoie i && (i === r || w.contains (r, i)) || (e.type = o.origType, n = o.handler.apply (this, arguments), e.type = t), n
            }
        }
    }), w.fn.extend ({
        sur: function (e, t, n, r) {
            retourne De (this, e, t, n, r)
        },
        un: fonction (e, t, n, r) {
            retourne De (this, e, t, n, r, 1)
        },
        off: fonction (e, t, n) {
            var r, i;
            if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r.origType, r. sélecteur, r.handler), this;
            if ("objet" == typeof e) {
                pour (i dans e) this.off (i, t, e [i]);
                retourne ça
            }
            retourne! 1! == t && "fonction"! = typeof t || (n = t, t = vide 0),! 1 === n && (n = ke), this.each (fonction () {
                w.événement.remove (ceci, e, n, t)
            })
        }
    });
    var Ne = / <(?! aire | br | col | embed | hr | img | entrée | lien | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f ] *) [^>] *) \ /> / gi,
        Ae = / <script | <style | <lien / i,
        je = /checked\s*(?:[^= </font>|=\s*.checked.)/i,
        qe = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g;

    fonction Le (e, t) {
        renvoie N (e, "table") && N (11! == t.nodeType? t: t.firstChild, "tr")? w (e) .children ("tbody") [0] || e: e
    }

    fonction He (e) {
        retourne e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e
    }

    fonction Oe (e) {
        renvoie "true /" === (e.type || "") .slice (0, 5)? e.type = e.type.slice (5): e.removeAttribute ("type"), e
    }

    fonction Pe (e, t) {
        var n, r, i, o, a, s, u, l;
        si (1 === t.nodeType) {
            if (J.hasData (e) && (o = J.access (e), a = J.set (t, o), l = o.events)) {
                supprimer a.handle, a.events = {};
                pour (i en l)
                    pour (n = 0, r = l [i] .longueur; n <r; n ++) w.event.add (t, i, l [i] [n])
            }
            K.hasData (e) && (s = K.accès (e), u = w.extend ({}, s), K.set (t, u))
        }
    }

    function Me (e, t) {
        var n = t.nodeName.toLowerCase ();
        "input" === n && pe.test (e.type)? t.checked = e.checked: "input"! == n && "textarea"! == n || (t.defaultValue = e.defaultValue)
    }

    fonction Re (e, t, n, r) {
        t = a.apply ([], t);
        var i, o, s, u, l, c, f = 0,
            p = e.longueur,
            d = p - 1,
            y = t [0],
            v = g (y);
        if (v || p> 1 && "string" == typeof y &&! h.checkClone && je.test (y)) renvoie e.each (fonction (i) {
            var o = e.eq (i);
            v && (t [0] = y.call (this, i, o.html ())), Re (o, t, n, r)
        });
        if (p && (i = xe (t, e [0] .ownerDocument,! 1, e, r), o = i.firstChild, 1 === i.childNodes.length && (i = o), o | | r)) {
            pour (u = (s = w.map (ye (i, "script"), He)). length; f <p; f ++) l = i, f! == d && (l = w.clone (l ,! 0,! 0), u && w.merge (s, ye (l, "script"))), n.call (e [f], l, f);
            si tu)
                pour (c = s [s.longueur - 1] .ownerDocument, w.map (s, Oe), f = 0; f <u; f ++) l = s [f], he.test (l.type || "") &&! J.access (l, "globalEval") && w.contains (c, l) && (l.src && "module"! == (l.type || "") .toLowerCase ()? w._evalUrl && w._evalUrl (l.src): m (l.textContent.replace (qe, ""), c, l))
        }
        retour e
    }

    fonction Ie (e, t, n) {
        pour (var r, i = t? w.filtre (t, e): e, o = 0; nul! = (r = i [o]); o ++) n || 1! == r.nodeType || w.cleanData (ye (r)), r.parentNode && (n && w.contains (r.ownerDocument, r) && ve (ye (r, "script")), r.parentNode.removeChild (r));
        retour e
    }
    w.extend ({
        htmlPrefilter: function (e) {
            return e.replace (Ne, "<$ 1> </ $ 2>")
        },
        clone: ​​fonction (e, t, n) {
            var r, i, o, a, s = e.cloneNode (! 0),
                u = w.contains (e.ownerDocument, e);
            if (! (h.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || w.isXMLDoc (e)))
                pour (a = ye (s), r = 0, i = (o = ye (e)). length; r <i; r ++) Me (o [r], a [r]);
            si (t)
                si (n)
                    pour (o = o || ye (e), a = a || ye (s), r = 0, i = o.length; r <i; r ++) Pe (o [r], a [r]) ;
                sinon Pe (e, s);
            return (a = ye (s, "script")). longueur> 0 && ve (a,! u && ye (e, "script")), s
        },
        cleanData: function (e) {
            pour (var t, n, r, i = w.event.special, o = 0; void 0! == (n = e [o]); o ++)
                si (Y (n)) {
                    si (t = n [J.expando]) {
                        if (t. événements)
                            pour (r en t.événements) i [r]? w.event.remove (n, r): w.removeEvent (n, r, t.handle);
                        n [J.expando] = vide 0
                    }
                    n [K.expando] && (n [K.expando] = void 0)
                }
        }
    }), w.fn.extend ({
        détacher: function (e) {
            retourne Ie (this, e,! 0)
        },
        supprimer: function (e) {
            retour Ie (this, e)
        },
        texte: fonction (e) {
            retourne z (ceci, fonction (e) {
                return void 0 === e? w.text (this): this.empty (). each (function () {
                    1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)
                })
            }, null, e, arguments.length)
        },
        append: function () {
            retourne Re (ceci, arguments, fonction (e) {
                1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Le (this, e) .appendChild (e)
            })
        },
        préfixer: function () {
            retourne Re (ceci, arguments, fonction (e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Le (ceci, e);
                    t.insertBefore (e, t.firstEnfant)
                }
            })
        },
        avant: function () {
            retourne Re (ceci, arguments, fonction (e) {
                this.parentNode && this.parentNode.insertBefore (e, this)
            })
        },
        après: function () {
            retourne Re (ceci, arguments, fonction (e) {
                this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)
            })
        },
        vide: function () {
            pour (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (w.cleanData (ye (e,! 1)), e.textContent = " ");
            retourne ça
        },
        clone: ​​fonction (e, t) {
            renvoie e = null! = e && e, t = null == t? e: t, this.map (function () {
                retourne w.clone (this, e, t)
            })
        },
        html: fonction (e) {
            retourne z (ceci, fonction (e) {
                var t = ceci [0] || {},
                    n = 0,
                    r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e &&! Ae.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ()]) {
                    e = w.htmlPréfiltre (e);
                    essayez {
                        pour (; n <r; n ++) 1 === (t = this [n] || {}). nodeType && (w.cleanData (ye (t,! 1)), t.innerHTML = e);
                        t = 0
                    } catch (e) {}
                }
                t && this.empty (). append (e)
            }, null, e, arguments.length)
        },
        replaceWith: function () {
            var e = [];
            retourne Re (ceci, arguments, fonction (t) {
                var n = this.parentNode;
                w.inArray (this, e) <0 && (w.cleanData (ye (this)), n && n.replaceChild (t, this))
            }, e)
        }
    }), w.chaque ({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "avant",
        insertAfter: "après",
        replaceAll: "replaceWith"
    }, fonction (e, t) {
        w.fn [e] = fonction (e) {
            pour (var n, r = [], i = w (e), o = i.longueur - 1, a = 0; a <= o; a ++) n = a === o? ceci: this.clone (! 0), w (i [a]) [t] (n), s.apply (r, n.get ());
            retourne this.pushStack (r)
        }
    });
    var We = new RegExp ("^ (" + re + ") (?! px) [az%] + $", "i"),
        $ e = fonction (t) {
            var n = t.ownerDocument.defaultView;
            retourne n && n.opener || (n = e), n.getComputedStyle (t)
        },
        Be = new RegExp (oe.join ("|"), "i");
    ! fonction () {
        fonction t () {
            if (c) {
                l.style.cssText = "position: absolue; gauche: -11111px; largeur: 60px; margin-top: 1px; padding: 0; border: 0", c.style.cssText = "position: relative; display: block; box-sizing: border-box; débordement: défilement; marge: auto; bordure: 1px; remplissage: 1px; largeur: 60%; haut: 1% ", be.appendChild (l) .appendChild (c);
                var t = e.getComputedStyle (c);
                i = "1%"! == t.top, u = 12 === n (t.marginLeft), c.style.right = "60%", s = 36 === n (t.right), o = 36 === n (t.width), c.style.position = "absolu", a = 36 === c.offsetWidth || "absolu", be.removeChild (l), c = null
            }
        }

        fonction n (e) {
            return Math.round (parseFloat (e))
        }
        var i, o, a, s, u, l = r.createElement ("div"),
            c = r.createElement ("div");
        c.style && (c.style.backgroundClip = "content-box", c.cloneNode (! 0) .style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend (h, {
            boxSizingReliable: function () {
                retourner à
            },
            pixelBoxStyles: function () {
                retour t (), s
            },
            pixelPosition: function () {
                retourne t (), i
            },
            fiableMarginLeft: function () {
                retourne t (), u
            },
            scrollboxSize: function () {
                retourne t (), a
            }
        }))
    } ();

    fonction Fe (e, t, n) {
        var r, i, o, a, s = e.style;
        return (n = n || $ e (e)) && (""! == (a = n.getPropertyValue (t) || n [t]) || w.contains (e.ownerDocument, e) || (a = w.style (e, t)),! h.pixelBoxStyles () && We.test (a) && Be.test (t) && (r = s.width, i = s.minWidth, o = s .maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a
    }

    fonction _e (e, t) {
        revenir {
            get: function () {
                if (! e ()) return (this.get = t) .apply (this, arguments);
                supprimer this.get
            }
        }
    }
    var ze = /^(none|table(?!-c[ea </font>).+)/,
        Xe = / ^ - /,
        Ue = {
            position: "absolue",
            visibilité: "caché",
            bloc de visualisation"
        },
        Ve = {
            letterSpacing: "0",
            fontWeight: "400"
        },
        Ge = ["Webkit", "Moz", "ms"],
        Ye = r.createElement ("div"). Style;

    fonction Qe (e) {
        if (e dans Ye) retourne e;
        var t = e [0] .toUpperCase () + e.slice (1),
            n = Ge.length;
        tandis que (n--)
            si ((e = Ge [n] + t) dans Ye) renvoie e
    }

    fonction Je (e) {
        var t = w.cssProps [e];
        retour t || (t = w.cssProps [e] = Qe (e) || e), t
    }

    fonction Ke (e, t, n) {
        var r = ie.exec (t);
        retourner r? Math.max (0, r [2] - (n || 0)) + (r [3] || "px"): t
    }

    fonction Ze (e, t, n, r, i, o) {
        var a = "largeur" ​​=== t? dix,
            s = 0,
            u = 0;
        if (n === (r? "border": "content")) return 0;
        pour (; a <4; a + = 2) "margin" === n && (u + = w.css (e, n + oe [a],! 0, i)), r? ("contenu" === n && (u - = w.css (e, "remplissage" + oe [a],! 0, i)), "marge"! == n && (u - = w.css (e, "border" + oe [a] + "Width",! 0, i))): (u + = w.css (e, "padding" + oe [a],! 0, i), " padding "! == n? u + = w.css (e," border "+ oe [a] +" Width ",! 0, i): s + = w.css (e," border "+ oe [ a] + "Largeur",! 0, i));
        return! r && o> = 0 && (u + = Math.max (0, Math.ceil (e ["offset" + t [0] .toUpperCase () + t.slice (1)] - o - u - s - .5))), u
    }

    fonction et (e, t, n) {
        var r = $ e (e),
            i = Fe (e, t, r),
            o = "border-box" === w.css (e, "boxSizing",! 1, r),
            a = o;
        if (We.test (i)) {
            si (! n) renvoie i;
            i = "auto"
        }
        retourne a = a && (h.boxSizingReliable () || i === e.style [t]), ("auto" === i ||! parseFloat (i) && "inline" === w.css (e, "affichage",! 1, r)) && (i = e ["offset" + t [0] .toUpperCase () + t.slice (1)], a =! 0), (i = parseFloat (i) || 0) + Ze (e, t, n || (o? "border": "content"), a, r, i) + "px"
    }
    w.extend ({
        cssHooks: {
            opacité: {
                get: function (e, t) {
                    si (t) {
                        var n = Fe (e, "opacité");
                        retourne "" === n? "1": n
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount:! 0,
            columnCount:! 0,
            fillOpacity:! 0,
            flexGrow:! 0,
            flexShrink:! 0,
            fontWeight:! 0,
            lineHeight:! 0,
            opacité:! 0,
            ordre:! 0,
            orphelins:! 0,
            veuves:! 0,
            zIndex:! 0,
            zoom:! 0
        },
        cssProps: {},
        style: fonction (e, t, n, r) {
            if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {
                var i, o, a, s = G (t),
                    u = test Xe (t),
                    l = e.style;
                if (u || (t = Je (s)), a = w.cssHooks [t] || w.cssHooks [s], void 0 === n) renvoie un && "get" dans un && void 0! == (i = a.get (e,! 1, r))? i: l [t];
                "string" == (o = typeof n) && (i = ie.exec (n)) && i [1] && (n = ue (e, t, i), o = "nombre"), nul! = n && n === n && ("nombre" === o && (n + = i && i [3] || (w.cssNumber [s]? "": "px")), h.clearCloneStyle | | ""! == n || 0! == t.indexOf ("background") || (l [t] = "inherit"), un && "set" dans un && void 0 === (n = a.set (e, n, r)) || (u? l.setProperty (t, n): l [t] = n))
            }
        },
        css: fonction (e, t, n, r) {
            var i, o, a, s = G (t);
            retourne Xe.test (t) || (t = Je (s)), (a = w.cssHooks [t] || w.cssHooks [s]) && "get" dans un && (i = a.get (e,! 0, n)), vide 0 === i && (i = Fe (e, t, r)), "normal" === i && t dans Ve && (i = Ve [t]), "" === n || n? (o = parseFloat (i),! 0 === n || isFinite (o)? o || 0: i): i
        }
    }), w.each (["hauteur", "largeur"], fonction (e, t) {
        w.cssHooks [t] = {
            get: function (e, n, r) {
                if (n) return! ze.test (w.css (e, "afficher")) || e.getClientRects (). length && e.getBoundingClientRect (). width? et (e, t, r): se (e, Ue, fonction () {
                    retourne et (e, t, r)
                })
            },
            set: fonction (e, n, r) {
                var i, o = $ e (e),
                    a = "border-box" === w.css (e, "boxSizing",! 1, o),
                    s = r && Ze (e, t, r, a, o);
                renvoie un && h.scrollboxSize () === o.position && (s - = Math.ceil (e ["offset" + t [0] .toUpperCase () + t.slice (1)] - parseFloat (o [ t]) - Ze (e, t, "frontière",! 1, o) - .5)), s && (i = ie.exec (n)) && "px"! == (i [3] | | "px") && (e.style [t] = n, n = w.css (e, t)), Ke (e, n, s)
            }
        }
    }), w.cssHooks.marginLeft = _e (h.reliableMarginLeft, function (e, t) {
        if (t) return (parseFloat (Fe (e, "marginLeft")) || e.getBoundingClientRect (). left - se (e, {
            marginLeft: 0
        }, fonction () {
            return e.getBoundingClientRect (). left
        })) + "px"
    }), w.chaque ({
        marge: "",
        rembourrage: "",
        largeur de la bordure"
    }, fonction (e, t) {
        w.cssHooks [e + t] = {
            développer: fonction (n) {
                pour (var r = 0, i = {}, o = "string" == typeof n? n.split (""): [n]; r <4; r ++) i [e + oe [r] + t ] = o [r] || o [r - 2] || o [0];
                retourne je
            }
        }, "margin"! == e && (w.cssHooks [e + t] .set = Ke)
    }), w.fn.extend ({
        css: fonction (e, t) {
            retourne z (this, function (e, t, n) {
                var r, i, o = {},
                    a = 0;
                si (Array.isArray (t)) {
                    pour (r = $ e (e), i = t.longueur; a <i; a ++) o [t [a]] = w.css (e, t [a],! 1, r);
                    retour o
                }
                retourne vide 0! == n? w.style (e, t, n): w.css (e, t)
            }, e, t, arguments.length> 1)
        }
    });

    fonction tt (e, t, n, r, i) {
        retourne un nouveau tt.prototype.init (e, t, n, r, i)
    }
    w.Tween = tt, tt.prototype = {
        constructeur: tt,
        init: fonction (e, t, n, r, i, o) {
            this.elem = e, this.prop = n, this.easing = i || w.easing._default, this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (w.cssNumber [n]? "": "px")
        },
        cur: function () {
            var e = tt.propHooks [this.prop];
            retourner e && e.get? e.get (ceci): tt.propHooks._default.get (ceci)
        },
        exécuter: function (e) {
            var t, n = tt.propHooks [this.prop];
            renvoyer this.options.duration? this.pos = t = w.easing [this.easing] (e, this.options.duration * e, 0, 1, this.options.duration): this.pos = t = e, this.now = (this .end - this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n.set (this): tt.propHooks._default.set (this), this
        }
    }, tt.prototype.init.prototype = tt.prototype, tt.propHooks = {
        _défaut: {
            get: function (e) {
                var t;
                retourne 1! == e.elem.nodeType || null! = e.elem [e.prop] && null == e.elem.style [e.prop]? e.elem [e.prop]: (t = w.css (e.elem, e.prop, "")) && "auto"! == t? t: 0
            },
            set: function (e) {
                w.fx.step [e.prop]? w.fx.step [e.prop] (e): 1! == e.elem.nodeType || null == e.elem.style [w.cssProps [e.prop]] &&! w.cssHooks [e.prop]? e.elem [e.prop] = e.now: w.style (e.elem, e.prop, e.now + e.unit)
            }
        }
    }, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = {
        set: function (e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)
        }
    }, w.easing = {
        linéaire: fonction (e) {
            retour e
        },
        swing: fonction (e) {
            retourne .5 - Math.cos (e * Math.PI) / 2
        },
        _par défaut: "swing"
    }, w.fx = tt.prototype.init, w.fx.step = {};
    var nt, rt, it = / ^ (?: basculer | afficher | masquer) $ /,
        ot = / queueHooks $ /;

    fonction à () {
        rt && (! 1 === r.hidden && e.requestAnimationFrame? e.requestAnimationFrame (at): e.setTimeout (at, w.fx.interval), w.fx.tick ())
    }

    function st () {
        retourne e.setTimeout (function () {
            nt = vide 0
        }), nt = Date.now ()
    }

    fonction ut (e, t) {
        var n, r = 0,
            i = {
                hauteur: e
            };
        pour (t = t? 1: 0; r <4; r + = 2 - t) i ["margin" + (n = oe [r])] = i ["padding" + n] = e;
        renvoie t && (i.opacity = i.width = e), i
    }

    fonction lt (e, t, n) {
        pour (var r, i = (pt.tweeners [t] || []). concat (pt.tweeners ["*"]), o = 0, a = i.length; o <a; o ++)
            if (r = i [o] .call (n, t, e)) renvoie r
    }

    fonction ct (e, t, n) {
        var r, i, o, a, s, u, l, c, f = "largeur" ​​en t || "hauteur" en t,
            p = ceci,
            d = {},
            h = e.style,
            g = e.nodeType && ae (e),
            y = J.get (e, "fxshow");
        n.queue || (null == (a = w._queueHooks (e, "fx")). unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
            a.unqueued || s ()
        }), a.unqueued ++, p.always (function () {
            p. toujours (function () {
                a.unqueued--, w.queue (e, "fx"). length || a.empty.fire ()
            })
        }));
        pour (r en t)
            si (i = t [r], it.test (i)) {
                if (supprimer t [r], o = o || "toggle" === i, i === (g? "hide": "show")) {
                    if ("show"! == i ||! y || void 0 === y [r]) continue;
                    g =! 0
                }
                d [r] = y && y [r] || w.style (e, r)
            } si ((u =! w.isEmptyObject (t)) ||! w.isEmptyObject (d)) {
            f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = y && y.display) && (l = J.get (e , "display")), "none" === (c = w.css (e, "display")) && (l? c = l: (fe ([e],! 0), l = e. style.display || l, c = w.css (e, "affichage"), fe ([e]))), ("inline" === c || "inline-block" === c && null ! = l) && "aucun" === w.css (e, "float") && (u || (p.done (fonction () {
                h.display = l
            }), null == l && (c = h.display, l = "none" === c? "": c)), h.display = "inline-block")), n.overflow && (h .overflow = "caché", p. toujours (function () {
                h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]
            })), u =! 1;
            pour (r en d) u || (y? "caché" dans y && (g = y.hidden): y = J.access (e, "fxshow", {
                affichage: l
            }), o && (y.hidden =! g), g && fe ([e],! 0), p.done (function () {
                g || fe ([e]), J.remove (e, "fxshow");
                pour (r en d) w.style (e, r, d [r])
            })), u = lt (g? y [r]: 0, r, p), r dans y || (y [r] = u.start, g && (u.end = u.start, u.start = 0))
        }
    }

    fonction ft (e, t) {
        var n, r, i, o, a;
        pour (n en e)
            si (r = G (n), i = t [r], o = e [n], Array.isArray (o) && (i = o [1], o = e [n] = o [0]) , n! == r && (e [r] = o, supprimer e [n]), (a = w.cssHooks [r]) && "développer" dans a) {
                o = a.expand (o), supprimer e [r];
                pour (n en o) n en e || (e [n] = o [n], t [n] = i)
            } sinon t [r] = i
    }

    fonction pt (e, t, n) {
        var r, i, o = 0,
            a = pt.prefilters.length,
            s = w.Deferred (). always (function () {
                supprimer u.elem
            }),
            u = fonction () {
                si (i) retourne! 1;
                pour (var t = nt || st (), n = Math.max (0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), o = 0, a = l.tweens.length; o <a; o ++) l.tweens [o] .run (r);
                retourner s.notifyWith (e, [l, r, n]), r <1 && a? n: (a || s.notifyWith (e, [l, 1, 0]), s.resolveWith (e, [l]),! 1)
            },
            l = s.promise ({
                elem: e,
                accessoires: w.extend ({}, t),
                opts: w.extend (! 0, {
                    specialEasing: {},
                    assouplissement: w.easing._default
                }, n),
                propriétés d'origine: t,
                originalOptions: n,
                startTime: nt || st (),
                durée: n. durée,
                préadolescents: [],
                createTween: fonction (t, n) {
                    var r = w.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts.easing);
                    retourne l.tweens.push (r), r
                },
                stop: fonction (t) {
                    var n = 0,
                        r = t? l.tweens.length: 0;
                    si (i) retournez ceci;
                    pour (i =! 0; n <r; n ++) l.tweens [n] .run (1);
                    retour t? (s.notifyWith (e, [l, 1, 0]), s.resolveWith (e, [l, t])): s.rejectWith (e, [l, t]), ce
                }
            }),
            c = l.props;
        pour (ft (c, l.opts.specialEasing); o <a; o ++)
            if (r = pt.prefilters [o] .call (l, e, c, l.opts)) renvoie g (r.stop) && (w._queueHooks (l.elem, l.opts.queue) .stop = r.stop.bind (r)), r;
        retourne w.map (c, lt, l), g (l.opts.start) && l.opts.start.call (e, l), l.progress (l.opts.progress) .done (l.opts .done, l.opts.complete) .fail (l.opts.fail) .always (l.opts.always), w.fx.timer (w.extend (u, {
            elem: e,
            anim: l,
            file d'attente: l.opts.queue
        })), l
    }
    w.Animation = w.extend (pt, {
            interpolateurs: {
                "*": [fonction (e, t) {
                    var n = this.createTween (e, t);
                    renvoie ue (n.elem, e, ie.exec (t), n), n
                }]
            },
            tweener: fonction (e, t) {
                g (e)? (t = e, e = ["*"]): e = e.match (M);
                pour (var n, r = 0, i = e.length; r <i; r ++) n = e [r], pt.tweeners [n] = pt.tweeners [n] || [], pt.tweeners [n] .unshift (t)
            },
            préfiltres: [ct],
            préfiltre: fonction (e, t) {
                t? pt.prefilters.unshift (e): pt.prefilters.push (e)
            }
        }), w.speed = fonction (e, t, n) {
            var r = e && "objet" == type de e? w.extend ({}, e): {
                complet: n || ! n && t || g (e) && e,
                durée: e,
                assouplissement: n && t || t &&! g (t) && t
            };
            retourner w.fx.off? r.duration = 0: "nombre"! = type de r.duration && (r.duration en w.fx.speeds? r.duration = w.fx.speeds [r.duration]: r.duration = w.fx. speeds._default), null! = r.queue &&! 0! == r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {
                g (r.old) && r.old.call (this), r.queue && w.dequeue (this, r.queue)
            }, r
        }, w.fn.extend ({
            fadeTo: fonction (e, t, n, r) {
                renvoie this.filter (ae) .css ("opacity", 0) .show (). end (). animate ({
                    opacité: t
                }, e, n, r)
            },
            animer: fonction (e, t, n, r) {
                var i = w.isEmptyObject (e),
                    o = w.vitesse (t, n, r),
                    a = fonction () {
                        var t = pt (this, w.extend ({}, e), o);
                        (i || J.get (this, "finish")) && t.stop (! 0)
                    };
                retourne a.finish = a, i || ! 1 === o.queue? this.each (a): this.queue (o.queue, a)
            },
            stop: fonction (e, t, n) {
                var r = fonction (e) {
                    var t = e.stop;
                    supprimer e.stop, t (n)
                };
                renvoie "string"! = typeof e && (n = t, t = e, e = void 0), t &&! 1! == e && this.queue (e || "fx", []), this. each (function () {
                    var t =! 0,
                        i = null! = e && e + "queueHooks",
                        o = w.heure,
                        a = J.get (ceci);
                    si (i) a [i] && a [i] .stop && r (a [i]);
                    autre
                        pour (i dans a) a [i] && a [i] .stop && ot.test (i) && r (a [i]);
                    pour (i = o.length; i--;) o [i] .elem! == this || null! = e && o [i] .queue! == e || (o [i] .anim.stop (n), t =! 1, o.splice (i, 1));
                    ! t && n || w.de file d'attente (ceci, e)
                })
            },
            terminer: function (e) {
                return! 1! == e && (e = e || "fx"), this.each (function () {
                    var t, n = J.get (ceci),
                        r = n [e + "file d'attente"],
                        i = n [e + "queueHooks"],
                        o = w.heure,
                        a = r? r.length: 0;
                    pour (n.finish =! 0, w.queue (this, e, []), i && i.stop && i.stop.call (this,! 0), t = o.length; t--;) o [t] .elem === this && o [t] .queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1));
                    pour (t = 0; t <a; t ++) r [t] && r [t] .finish && r [t] .finish.call (this);
                    supprimer n. terminer
                })
            }
        }), w.each (["toggle", "show", "hide"], function (e, t) {
            var n = w.fn [t];
            w.fn [t] = fonction (e, r, i) {
                retourne null == e || "booléen" == typeof e? n.apply (this, arguments): this.animate (ut (t,! 0), e, r, i)
            }
        }), w.chaque ({
            slideDown: ut ("afficher"),
            slideUp: ut ("cacher"),
            slideToggle: ut ("toggle"),
            fondu: {
                opacité: "montrer"
            },
            disparaître: {
                opacité: "cacher"
            },
            fadeToggle: {
                opacité: "basculer"
            }
        }, fonction (e, t) {
            w.fn [e] = fonction (e, n, r) {
                retourne this.animate (t, e, n, r)
            }
        }), w.timers = [], w.fx.tick = function () {
            var e, t = 0,
                n = w.heure;
            pour (nt = Date.now (); t <n.length; t ++) (e = n [t]) () || n [t]! == e || n. éclisse (t--, 1);
            n.length || w.fx.stop (), nt = vide 0
        }, w.fx.timer = fonction (e) {
            w.timers.push (e), w.fx.start ()
        }, w.fx.interval = 13, w.fx.start = function () {
            rt || (rt =! 0, à ())
        }, w.fx.stop = fonction () {
            rt = nul
        }, w.fx.speeds = {
            lent: 600,
            rapide: 200,
            _par défaut: 400
        }, w.fn.delay = fonction (t, n) {
            retourne t = w.fx? w.fx.speeds [t] || t: t, n = n || "fx", this.queue (n, function (n, r) {
                var i = e.setTimeout (n, t);
                r.stop = fonction () {
                    e.clearTimeout (i)
                }
            })
        },
        fonction () {
            var e = r.createElement ("entrée"),
                t = r.createElement ("sélectionner"). appendChild (r.createElement ("option"));
            e.type = "case à cocher", h.checkOn = ""! == e.value, h.optSelected = t.selected, (e = r.createElement ("input")). value = "t", e. type = "radio", h.radioValue = "t" === e.value
        } ();
    var dt, ht = w.expr.attrHandle;
    w.fn.extend ({
        attr: fonction (e, t) {
            retourne z (this, w.attr, e, t, arguments.length> 1)
        },
        removeAttr: function (e) {
            retourne this.each (function () {
                w.removeAttr (ceci, e)
            })
        }
    }), w.extend ({
        attr: fonction (e, t, n) {
            var r, i, o = e.nodeType;
            if (3! == o && 8! == o && 2! == o) renvoie "undefined" == typeof e.getAttribute? w.prop (e, t, n): (1 === o && w.isXMLDoc (e) || (i = w.attrHooks [t.toLowerCase ()] || (w.expr.match.bool. test (t)? dt: void 0)), void 0! == n? null === n? void w.removeAttr (e, t): i && "set" dans i && void 0! == (r = i.set (e, n, t))? r: (e.setAttribute (t, n + ""), n): i && "get" dans i && null! == (r = i.get ( e, t))? r: null == (r = w.find.attr (e, t))? void 0: r)
        },
        attrHooks: {
            type: {
                set: function (e, t) {
                    if (! h.radioValue && "radio" === t && N (e, "input")) {
                        var n = valeur e;
                        return e.setAttribute ("type", t), n && (e.value = n), t
                    }
                }
            }
        },
        removeAttr: fonction (e, t) {
            var n, r = 0,
                i = t && t.match (M);
            si (i && 1 === e.nodeType)
                tandis que (n = i [r ++]) e.removeAttribute (n)
        }
    }), dt = {
        set: fonction (e, t, n) {
            retour! 1 === t? w.removeAttr (e, n): e.setAttribute (n, n), n
        }
    }, w.each (w.expr.match.bool.source.match (/ \ w + / g), fonction (e, t) {
        var n = ht [t] || w.find.attr;
        ht [t] = fonction (e, t, r) {
            var i, o, a = t.toLowerCase ();
            retour r || (o = ht [a], ht [a] = i, i = nul! = n (e, t, r)? a: nul, ht [a] = o), i
        }
    });
    var gt = / ^ (?: input | select | textarea | button) $ / i,
        yt = / ^ (?: une | zone) $ / i;
    w.fn.extend ({
        prop: fonction (e, t) {
            retourne z (this, w.prop, e, t, arguments.length> 1)
        },
        removeProp: function (e) {
            retourne this.each (function () {
                supprimer ce [w.propFix [e] || e]
            })
        }
    }), w.extend ({
        prop: fonction (e, t, n) {
            var r, i, o = e.nodeType;
            if (3! == o && 8! == o && 2! == o) retourne 1 === o && w.isXMLDoc (e) || (t = w.propFix [t] || t, i = w.propHooks [t]), void 0! == n? i && "set" dans i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "get" dans i && null! == (r = i.get (e, t))? r: e [t]
        },
        propHooks: {
            tabIndex: {
                get: function (e) {
                    var t = w.find.attr (e, "tabindex");
                    retour t? parseInt (t, 10): gt.test (e.nodeName) || yt.test (e.nodeName) && e.href? 0: -1
                }
            }
        },
        propFix: {
            "pour": "htmlFor",
            "class": "className"
        }
    }), h.optSelected || (w.propHooks.selected = {
        get: function (e) {
            var t = e.parentNode;
            retourne t && t.parentNode && t.parentNode.selectedIndex, null
        },
        set: function (e) {
            var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
        }
    }), w.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        w.propFix [this.toLowerCase ()] = ceci
    });

    fonction vt (e) {
        return (e.match (M) || []). join ("")
    }

    fonction mt (e) {
        retourne e.getAttribute && e.getAttribute ("classe") || ""
    }

    fonction xt (e) {
        renvoyer Array.isArray (e)? e: "chaîne" == type de e? e.match (M) || []: []
    }
    w.fn.extend ({
        addClass: fonction (e) {
            var t, n, r, i, o, a, s, u = 0;
            if (g (e)) renvoie this.each (function (t) {
                w (this) .addClass (e.call (this, t, mt (this)))
            });
            si ((t = xt (e)). longueur)
                tandis que (n = this [u ++])
                    si (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {
                        a = 0;
                        while (o = t [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + "");
                        i! == (s = vt (r)) && n.setAttribute ("classe", s)
                    } renvoyer ceci
        },
        removeClass: function (e) {
            var t, n, r, i, o, a, s, u = 0;
            if (g (e)) renvoie this.each (function (t) {
                w (this) .removeClass (e.call (this, t, mt (this)))
            });
            if (! arguments.length) return this.attr ("class", "");
            si ((t = xt (e)). longueur)
                tandis que (n = this [u ++])
                    si (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {
                        a = 0;
                        tandis que (o = t [a ++])
                            while (r.indexOf ("" + o + "")> -1) r = r.replace ("" + o + "", "");
                        i! == (s = vt (r)) && n.setAttribute ("classe", s)
                    } renvoyer ceci
        },
        toggleClass: fonction (e, t) {
            var n = type de e,
                r = "chaîne" === n || Array.isArray (e);
            retourne "booléen" == typeof t && r? t? this.addClass (e): this.removeClass (e): g (e)? this.each (fonction (n) {
                w (ceci) .toggleClass (e.call (ceci, n, mt (ceci), t), t)
            }): this.each (function () {
                var t, i, o, a;
                si (r) {
                    i = 0, o = w (ceci), a = xt (e);
                    tandis que (t = a [i ++]) o.hasClass (t)? o.removeClass (t): o.addClass (t)
                } else void 0! == e && "booléen"! == n || ((t = mt (this)) && J.set (this, "__className__", t), this.setAttribute && this.setAttribute ("class", t ||! 1 === e? "": J. get (this, "__className__") || ""))
            })
        },
        hasClass: function (e) {
            var t, n, r = 0;
            t = "" + e + "";
            tandis que (n = this [r ++])
                if (1 === n.nodeType && ("" + vt (mt (n)) + "") .indexOf (t)> -1) return! 0;
            retour! 1
        }
    });
    var bt = / \ r / g;
    w.fn.extend ({
        val: fonction (e) {
            var t, n, r, i = ceci [0]; {
                if (arguments.length) return r = g (e), this.each (fonction (n) {
                    var i;
                    1 === this.nodeType && (null == (i = r? E.call (this, n, w (this) .val ()): e)? I = "": "number" == typeof i ? i + = "": Array.isArray (i) && (i = w.map (i, fonction (e) {
                        retourne null == e? "": e + ""
                    })), (t = w.valHooks [this.type] || w.valHooks [this.nodeName.toLowerCase ()]) && "set" in t && void 0! == t.set (this, i, "valeur") || (this.value = i))
                });
                if (i) return (t = w.valHooks [i.type] || w.valHooks [i.nodeName.toLowerCase ()]) && "get" dans t && void 0! == (n = t.get ( i, "valeur"))? n: "chaîne" == typeof (n = i.value)? n.replace (bt, ""): null == n? "": n
            }
        }
    }), w.extend ({
        valHooks: {
            option: {
                get: function (e) {
                    var t = w.find.attr (e, "valeur");
                    renvoie null! = t? t: vt (avec texte (e))
                }
            },
            sélectionnez: {
                get: function (e) {
                    var t, n, r, i = e.options,
                        o = e.selectedIndex,
                        a = "select-one" === e.type,
                        s = a? nul : [],
                        u = a? o + 1: i.longueur;
                    pour (r = o <0? u: a? o: 0; r <u; r ++)
                        if (((n = i [r]). selected || r === o) &&! n.disabled && (! n.parentNode.disabled ||! N (n.parentNode, "optgroup"))) {
                            if (t = w (n) .val (), a) renvoie t;
                            s.pousser (t)
                        } Retour
                },
                set: function (e, t) {
                    var n, r, i = e.options,
                        o = w.makeArray (t),
                        a = i.longueur;
                    while (a -) ((r = i [a]). selected = w.inArray (w.valHooks.option.get (r), o)> -1) && (n =! 0);
                    retour n || (e.selectedIndex = -1), o
                }
            }
        }
    }), w.each (["radio", "checkbox"], function () {
        w.valHooks [this] = {
            set: function (e, t) {
                if (Array.isArray (t)) renvoie e.checked = w.inArray (w (e) .val (), t)> -1
            }
        }, h.checkOn || (w.valHooks [this] .get = function (e) {
            return null === e.getAttribute ("valeur")? "on": e.value
        })
    }), h.focusin = "onfocusin" dans e;
    var wt = / ^ (?: focusinfocus | focusoutblur) $ /,
        Tt = fonction (e) {
            e.stopPropagation ()
        };
    w.extend (w.event, {
        déclencheur: fonction (t, n, i, o) {
            var a, s, u, l, c, p, d, h, v = [i || r],
                m = f.call (t, "type")? t.type: t,
                x = f.call (t, "espace de noms")? t.namespace.split ("."): [];
            if (s = h = u = i = i || r, 3! == i.nodeType && 8! == i.nodeType &&! wt.test (m + w.event.triggered) && (m.indexOf ( ".")> -1 && (m = (x = m.split (".")). Shift (), x.sort ()), c = m.indexOf (":") <0 && "on "+ m, t = t [w.expando]? t: nouveau w.Event (m," object "== typeof t && t), t.isTrigger = o? 2: 3, t.namespace = x.join ("."), t.rnamespace = t.namespace? new RegExp ("(^ | \\.)" + x.join ("\\. (?:. * \\. |)") + "( \\. | $) "): null, t.result = void 0, t.target || (t.target = i), n = null == n? [t]: w.makeArray (n, [t ]), d = w.event.special [m] || {}, o ||! d.trigger ||! 1! == d.trigger.apply (i, n))) {
                if (! o &&! d.noBubble &&! y (i)) {
                    pour (l = d.delegateType || m, wt.test (l + m) || (s = s.parentNode); s; s = s.parentNode) v.push (s), u = s;
                    u === (i.ownerDocument || r) && v.push (u.defaultView || u.parentWindow || e)
                }
                a = 0;
                tandis que ((s = v [a ++]) &&! t.isPropagationStopped ()) h = s, t.type = a> 1? l: d.bindType || m, (p = (J.get (s, "events") || {}) [t.type] && J.get (s, "handle")) && p.apply (s, n), (p = c && s [c]) && p.apply && Y (s) && (t.result = p.apply (s, n),! 1 === t.result && t.preventDefault ());
                retourne t.type = m, o || t.isDefaultPrevented () || d._default &&! 1! == d._default.apply (v.pop (), n) || ! Y (i) || c && g (i [m]) &&! y (i) && ((u = i [c]) && (i [c] = null), w.event.triggered = m, t.isPropagationStopped () && h .addEventListener (m, Tt), i [m] (), t.isPropagationStopped () && h.removeEventListener (m, Tt), w.event.triggered = void 0, u && (i [c] = u)) , t. résultat
            }
        },
        simuler: fonction (e, t, n) {
            var r = w.extend (nouveau w.Event, n, {
                type: e,
                isSimulé:! 0
            });
            w.event.trigger (r, nul, t)
        }
    }), w.fn.extend ({
        déclencheur: fonction (e, t) {
            retourne this.each (function () {
                w.event.trigger (e, t, ceci)
            })
        },
        triggerHandler: fonction (e, t) {
            var n = ceci [0];
            if (n) renvoie w.event.trigger (e, t, n,! 0)
        }
    }), h.focusin || avec chaque ({
        focus: "focusin",
        flou: "mise au point"
    }, fonction (e, t) {
        var n = fonction (e) {
            w.event.simulate (t, e.target, w.event.fix (e))
        };
        w.event.special [t] = {
            configuration: function () {
                var r = this.ownerDocument || ce,
                    i = J. accès (r, t);
                i || r.addEventListener (e, n,! 0), J.access (r, t, (i || 0) + 1)
            },
            démontage: function () {
                var r = this.ownerDocument || ce,
                    i = J. accès (r, t) - 1;
                je ? J.access (r, t, i): (r.removeEventListener (e, n,! 0), J.remove (r, t))
            }
        }
    });
    var Ct = e.location,
        Et = Date.now (),
        kt = / \? /;
    w.parseXML = fonction (t) {
        var n;
        if (! t || "string"! = typeof t) return null;
        essayez {
            n = (nouveau e.DOMParser) .parseFromString (t, "text / xml")
        } catch (e) {
            n = vide 0
        }
        renvoie n &&! n.getElementsByTagName ("parsererror"). length || w.error ("XML invalide:" + t), n
    };
    var St = / \ [\] $ /,
        Dt = / \ r? \ N / g,
        Nt = / ^ (?: soumettre | bouton | image | réinitialiser | fichier) $ / i,
        At = / ^ (?: input | select | textarea | keygen) / i;

    fonction jt (e, t, n, r) {
        var i;
        if (Array.isArray (t)) w.each (t, fonction (t, i) {
            n || St.test (e)? r (e, i): jt (e + "[" + ("object" == typeof i && null! = i? t: "") + "]", i, n, r)
        });
        sinon si (n || "objet"! == x (t)) r (e, t);
        autre
            pour (i dans t) jt (e + "[" + i + "]", t [i], n, r)
    }
    w.param = fonction (e, t) {
        var n, r = [],
            i = fonction (e, t) {
                var n = g (t)? t (): t;
                r [r.length] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)
            };
        if (Array.isArray (e) || e.jquery &&! w.isPlainObject (e)) w.each (e, function () {
            i (this.name, this.value)
        });
        autre
            pour (n en e) jt (n, e [n], t, i);
        retourne r.join ("&")
    }, w.fn.extend ({
        sérialiser: function () {
            retourne w.param (this.serializeArray ())
        },
        serializeArray: function () {
            renvoie this.map (function () {
                var e = w.prop (ceci, "éléments");
                retour e? w.makeArray (e): ceci
            }). filter (function () {
                var e = ce.type;
                renvoie this.name &&! w (this) .is (": disabled") && At.test (this.nodeName) &&! Nt.test (e) && (this.checked ||! pe.test (e))
            }). map (fonction (e, t) {
                var n = w (ceci) .val ();
                retourne null == n? null: Array.isArray (n)? w.map (n, fonction (e) {
                    revenir {
                        nom: t.name,
                        valeur: e.replace (Dt, "\ r \ n")
                    }
                }): {
                    nom: t.name,
                    valeur: n.replace (Dt, "\ r \ n")
                }
            }).avoir()
        }
    });
    var qt = /% 20 / g,
        Lt = /#.*$/,
        Ht = / ([? &]) _ = [^ &] * /,
        Ot = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm,
        Pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        Mt = / ^ (?: GET | HEAD) $ /,
        Rt = / ^ \ / \ //,
        It = {},
        Wt = {},
        $ t = "* /". concat ("*"),
        Bt = r.createElement ("a");
    Bt.href = Ct.href;

    fonction Ft (e) {
        fonction de retour (t, n) {
            "chaîne"! = typeof t && (n = t, t = "*");
            var r, i = 0,
                o = t.toLowerCase (). match (M) || [];
            si (g (n))
                tandis que (r = o [i ++]) "+" === r [0]? (r = r.slice (1) || "*", (e [r] = e [r] || []). unshift (n)): (e [r] = e [r] || [ ]). pousser (n)
        }
    }

    fonction _t (e, t, n, r) {
        var i = {},
            o = e === Wt;

        fonctionne comme) {
            var u;
            renvoie i [s] =! 0, w.chaque (e [s] || [], fonction (e, s) {
                var l = s (t, n, r);
                retourne "chaîne"! = typeof l || o || je [l]? o? ! (u = l): void 0: (t.dataTypes.unshift (l), a (l),! 1)
            }), u
        }
        retourne un (t.dataTypes [0]) || ! i ["*"] && a ("*")
    }

    fonction zt (e, t) {
        var n, r, i = w.ajaxSettings.flatOptions || {};
        pour (n en t) vide 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]);
        retourne r && w.extend (! 0, e, r), e
    }

    fonction Xt (e, t, n) {
        var r, i, o, a, s = e. contenu,
            u = e.dataTypes;
        while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Content-Type"));
        si (r)
            pour (i en s)
                si (s [i] && s [i] .test (r)) {
                    u.unshift (i);
                    Pause
                } si (u [0] dans n) o = u [0];
        autre {
            pour (i dans n) {
                if (! u [0] || e.converters [i + "" + u [0]]) {
                    o = i;
                    Pause
                }
                a || (a = i)
            }
            o = o || une
        }
        si (o) retourne o! == u [0] && u.unshift (o), n [o]
    }

    fonction Ut (e, t, n, r) {
        var i, o, a, s, u, l = {},
            c = e.dataTypes.slice ();
        si (c [1])
            pour (a dans e.converters) l [a.toLowerCase ()] = e.converters [a];
        o = c.shift ();
        tandis que (o)
            if (e.responseFields [o] && (n [e.responseFields [o]] = t),! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o , o = c.shift ())
                si ("*" === o) o = u;
                sinon si ("*"! == u && u! == o) {
            si (! (a = l [u + "" + o] || l ["*" + o]))
                pour (i en l)
                    if ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] || l ["*" + s [0]]) ) {
                        ! 0 === a? a = l [i]:! 0! == l [i] && (o = s [0], c.unshift (s [1]));
                        Pause
                    } si (! 0! == a)
                if (a && e ["lance"]) t = a (t);
                sinon essayez {
                    t = a (t)
                } catch (e) {
                    revenir {
                        état: "parsererror",
                        erreur: un? e: "Aucune conversion de" + u + "à" + o
                    }
                }
        }
        revenir {
            état: "succès",
            données: t
        }
    }
    w.extend ({
        actif: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Ct.href,
            tapez: "GET",
            isLocal: Pt.test (Ct.protocol),
            global:! 0,
            processData:! 0,
            asynchrone:! 0,
            contentType: "application / x-www-form-urlencoded; charset = UTF-8",
            accepte: {
                "*": $ t,
                texte: "text / plain",
                html: "texte / html",
                xml: "application / xml, texte / xml",
                json: "application / json, texte / javascript"
            },
            Contenu: {
                xml: / \ bxml \ b /,
                html: / \ bhtml /,
                json: / \ bjson \ b /
            },
            responseFields: {
                xml: "responseXML",
                texte: "responseText",
                json: "responseJSON"
            },
            convertisseurs: {
                "* text": Chaîne,
                "texte html":! 0,
                "text json": JSON.parse,
                "texte xml": w.parseXML
            },
            flatOptions: {
                url:! 0,
                contexte:! 0
            }
        },
        ajaxSetup: fonction (e, t) {
            retour t? zt (zt (e, w.ajaxSettings), t): zt (w.ajaxSettings, e)
        },
        ajaxPrefilter: Ft (It),
        ajaxTransport: Ft (Wt),
        ajax: fonction (t, n) {
            "objet" == type de t && (n = t, t = vide 0), n = n || {};
            var i, o, a, s, u, l, c, f, p, d, h = w.ajaxSetup ({}, n),
                g = h.context || h,
                y = h.context && (g.nodeType || g.jquery)? w (g): w.événement,
                v = w.Deferred (),
                m = w.Callbacks ("une fois mémoire"),
                x = h.statusCode || {},
                b = {},
                T = {},
                C = "annulé",
                E = {
                    readyState: 0,
                    getResponseHeader: fonction (e) {
                        var t;
                        if (c) {
                            si (! s) {
                                s = {};
                                tandis que (t = Ot.exec (a)) s [t [1] .toLowerCase ()] = t [2]
                            }
                            t = s [e.toLowerCase ()]
                        }
                        retourne null == t? nul: t
                    },
                    getAllResponseHeaders: function () {
                        retour c? a: nul
                    },
                    setRequestHeader: fonction (e, t) {
                        renvoie null == c && (e = T [e.toLowerCase ()] = T [e.toLowerCase ()] || e, b [e] = t), ce
                    },
                    overrideMimeType: function (e) {
                        renvoie null == c && (h.mimeType = e), ceci
                    },
                    statusCode: function (e) {
                        var t;
                        si (e)
                            if (c) E. toujours (e [E.status]);
                            autre
                                pour (t dans e) x [t] = [x [t], e [t]];
                        retourne ça
                    },
                    abandonner: function (e) {
                        var t = e || C;
                        retourne i && i.abort (t), k (0, t), this
                    }
                };
            if (v.promise (E), h.url = ((t || h.url || Ct.href) + "") .replace (Rt, Ct.protocol + "//"), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || "*"). toLowerCase (). match (M) || [""], null == h.crossDomain) {
                l = r.createElement ("a");
                essayez {
                    l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host! = l.protocol + "//" + l.host
                } catch (e) {
                    h.crossDomain =! 0
                }
            }
            if (h.data && h.processData && "string"! = typeof h.data && (h.data = w.param (h.data, h.traditional)), _t (It, h, n, E), c) retourner E;
            (f = w.event && h.global) && 0 == w.active ++ && w.event.trigger ("ajaxStart"), h.type = h.type.toUpperCase (), h.hasContent =! Mt.test (h.type), o = h.url.replace (Lt, ""), h.hasContent? h.data && h.processData && 0 === (h.contentType || "") .indexOf ("application / x-www-form-urlencoded") && (h.data = h.data.replace (qt, "+")): (d = h.url.slice (o.length), h.data && (h.processData || "string" == typeof h.data) && (o + = (kt.test ( o)? "&": "?") + h.data, supprimer h.data),! 1 === h.cache && (o = o.replace (Ht, "$ 1"), d = (kt. test (o)? "&": "?") + "_ =" + Et ++ + d), h.url = o + d), h.ifModified && (w.lastModified [o] && E.
            pour (p dans h.headers) E.setRequestHeader (p, h.headers [p]);
            if (h.beforeSend && (! 1 === h.beforeSend.call (g, E, h) || c)) return E.abort ();
            if (C = "abandonner", m.add (h.complete), E.done (h.success), E.fail (h.error), i = _t (Wt, h, n, E)) {
                if (E.readyState = 1, f && y.trigger ("ajaxSend", [E, h]), c) return E;
                h.async && h.timeout> 0 && (u = e.setTimeout (function () {
                    E.abort ("timeout")
                }, h.timeout));
                essayez {
                    c =! 1, i.send (b, k)
                } catch (e) {
                    si (c) lancer e;
                    k (-1, e)
                }
            } else k (-1, "Pas de transport");

            fonction k (t, n, r, s) {
                var l, p, d, b, T, C = n;
                c || (c =! 0, u && e.clearTimeout (u), i = void 0, a = s || "", E.readyState = t> 0? 4: 0, l = t> = 200 && t <300 || 304 === t, r && (b = Xt (h, E, r)), b = Ut (h, b, E, l), l? (H.ifModified && ((T = E.getResponseHeader ("Last-Modified")) && (w.lastModified [o] = T), (T = E.getResponseHeader ("etag")) && (w.etag [o] = T)), 204 === t || "HEAD" === h.type? C = "nocontent": 304 === t? C = "notmodified": (C = b.state, p = b.data, l =! (D = b .error))): (d = C,! t && C || (C = "erreur", t <0 && (t = 0))), E.status = t, E.statusText = (n || C) + "", l? V.resolveWith (g, [p, C, E]): v.rejectWith (g, [E, C, d]), E.statusCode (x), x = void 0, f && y.trigger (l? "
            }
            retour E
        },
        getJSON: fonction (e, t, n) {
            retourne w.get (e, t, n, "json")
        },
        getScript: fonction (e, t) {
            retourne w.get (e, void 0, t, "script")
        }
    }), w.each (["get", "post"], function (e, t) {
        w [t] = fonction (e, n, r, i) {
            renvoie g (n) && (i = i || r, r = n, n = vide 0), w.ajax (w.extend ({
                url: e,
                type: t,
                dataType: i,
                données: n,
                succès: r
            }, w.isPlainObject (e) && e))
        }
    }), w._evalUrl = fonction (e) {
        retourne w.ajax ({
            url: e,
            tapez: "GET",
            dataType: "script",
            cache:! 0,
            asynchrone:! 1,
            global:! 1,
            "jette":! 0
        })
    }, w.fn.extend ({
        wrapAll: function (e) {
            var t;
            renvoie ce [0] && (g (e) && (e = e.call (ce [0])), t = w (e, ce [0] .ownerDocument) .eq (0) .clone (! 0) , ce [0] .parentNode && t.insertBefore (ce [0]), t.map (function () {
                var e = ceci;
                while (e.firstElementChild) e = e.firstElementChild;
                retour e
            }). append (this)), this
        },
        wrapInner: function (e) {
            retourner g (e)? this.each (fonction (t) {
                w (this) .wrapInner (e.call (this, t))
            }): this.each (function () {
                var t = w (ceci),
                    n = t.contenu ();
                n.longueur? n.wrapAll (e): t.append (e)
            })
        },
        wrap: function (e) {
            var t = g (e);
            retourne this.each (function (n) {
                w (ceci) .wrapAll (t? e.call (ceci, n): e)
            })
        },
        déplier: function (e) {
            return this.parent (e) .not ("body"). each (function () {
                w (this) .replaceWith (this.childNodes)
            }), ce
        }
    }), w.expr.pseudos.hidden = fonction (e) {
        retour! w.expr.pseudos.visible (e)
    }, w.expr.pseudos.visible = fonction (e) {
        return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)
    }, w.ajaxSettings.xhr = function () {
        essayez {
            retourne une nouvelle demande e.XMLHttpRequest
        } catch (e) {}
    };
    var Vt = {
            0: 200,
            1223: 204
        },
        Gt = w.ajaxSettings.xhr ();
    h.cors = !! Gt && "withCredentials" dans Gt, h.ajax = Gt = !! Gt, w.ajaxTransport (function (t) {
        var n, r;
        if (h.cors || Gt &&! t.crossDomain) return {
            envoyer: fonction (i, o) {
                var a, s = t.xhr ();
                if (s.open (t.type, t.url, t.async, t.username, t.password), t.xhrFields)
                    pour (a dans t.xhrFields) s [a] = t.xhrFields [a];
                t.mimeType && s.overrideMimeType && s.overrideMimeType (t.mimeType), t.crossDomain || i ["X-Requested-With"] || (i ["X-Requested-With"] = "XMLHttpRequest");
                pour (a dans i) s.setRequestHeader (a, i [a]);
                n = fonction (e) {
                    fonction de retour () {
                        n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e? s.abort (): "error" === e ? "nombre"! = type de statut? o (0, "erreur"): o (s.status, s.statusText): o (Vt [s.status] || s.status, s.statusText, " text "! == (s.responseType ||" text ") ||" string "! = typeof s.responseText? {
                            binaire: s. réponse
                        }: {
                            texte: s.responseText
                        }, s.getAllResponseHeaders ()))
                    }
                }, s.onload = n (), r = s.onerror = s.ontimeout = n ("erreur"), void 0! == s.onabort? s.onabort = r: s.onreadystatechange = function () {
                    4 === s.readyState && e.setTimeout (function () {
                        n && r ()
                    })
                }, n = n ("abandonner");
                essayez {
                    s.send (t.hasContent && t.data || null)
                } catch (e) {
                    si (n) jette e
                }
            },
            abandonner: function () {
                n && n ()
            }
        }
    }), w.ajaxPrefilter (fonction (e) {
        e.crossDomain && (e.contents.script =! 1)
    }), w.ajaxSetup ({
        accepte: {
            script: "texte / javascript, application / javascript, application / ecmascript, application / x-ecmascript"
        },
        Contenu: {
            script: / \ b (?: java | ecma) script \ b /
        },
        convertisseurs: {
            "script de texte": function (e) {
                retourne w.globalEval (e), e
            }
        }
    }), w.ajaxPrefilter ("script", fonction (e) {
        void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET")
    }), w.ajaxTransport ("script", fonction (e) {
        if (e.crossDomain) {
            var t, n;
            revenir {
                envoyer: fonction (i, o) {
                    t = w ("<script>") .prop ({
                        charset: e.scriptCharset,
                        src: e.url
                    }). on ("erreur de chargement", n = fonction (e) {
                        t.remove (), n = null, e && o ("erreur" === e.type? 404: 200, e.type)
                    }), r.head.appendChild (t [0])
                },
                abandonner: function () {
                    n && n ()
                }
            }
        }
    });
    var Yt = [],
        Qt = / (=) \? (? = & | $) | \? \? /;
    w.ajaxSetup ({
        jsonp: "rappel",
        jsonpCallback: function () {
            var e = Yt.pop () || w.expando + "_" + Et ++;
            renvoie ceci [e] =! 0, e
        }
    }), w.ajaxPrefilter ("json jsonp", function (t, n, r) {
        var i, o, a, s =! 1! == t.jsonp && (Qt.test (t.url)? "url": "string" == typeof t.data && 0 === (t.contentType) || "") .indexOf ("application / x-www-form-urlencoded") && Qt.test (t.data) && "data");
        if (s || "jsonp" === t.dataTypes [0]) renvoie i = t.jsonpCallback = g (t.jsonpCallback)? t.jsonpCallback (): t.jsonpCallback, s? t [s] = t [s] .replace (Qt, "$ 1" + i):! 1! == t.jsonp && (t.url + = (kt.test (t.url)? "&": "?") + t.jsonp + "=" + i), t.converters ["script json"] = function () {
            retourner un || w.error (i + "n'a pas été appelé"), a [0]
        }, t.dataTypes [0] = "json", o = e [i], e [i] = function () {
            a = arguments
        }, r.always (function () {
            vide 0 === o? w (e) .removeProp (i): e [i] = o, t [i] && (t.jsonpCallback = n.jsonpCallback, Yt.push (i)), a && g (o) && o (a [ 0]), a = o = vide 0
        }), "script"
    }), h.createHTMLDocument = function () {
        var e = r.implementation.createHTMLDocument (""). body;
        return e.innerHTML = "<form> </form> <form> </form>", 2 === e.childNodes.length
    } (), w.parseHTML = fonction (e, t, n) {
        if ("string"! = typeof e) return [];
        "booléen" == typeof t && (n = t, t =! 1);
        var i, o, a;
        retour t || (h.createHTMLDocument? ((i = (t = r.implementation.createHTMLDocument ("")). createElement ("base")). href = r.location.href, t.head.appendChild (i)): t = r), o = A.exec (e), a =! n && [], o? [t.createElement (o [1])]: (o = xe ([e], t, a), a && a.longueur && w (a) .remove (), w.merge ([], o. childNodes))
    }, w.fn.load = fonction (e, t, n) {
        var r, i, o, a = ceci,
            s = e.indexOf ("");
        renvoie s> -1 && (r = vt (e.slice (s)), e = e.slice (0, s)), g (t)? (n = t, t = void 0): t && "object" == typeof t && (i = "POST"), a.length> 0 && w.ajax ({
            url: e,
            type: i || "AVOIR",
            dataType: "html",
            données: t
        }). done (fonction (e) {
            o = arguments, a.html (r? w ("<div>") .append (w.parseHTML (e)). find (r): e)
        }). toujours (n && fonction (e, t) {
            a.each (fonction () {
                n.apply (this, o || [e.responseText, t, e])
            })
        }), ce
    }, w.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
        w.fn [t] = fonction (e) {
            renvoie this.on (t, e)
        }
    }), w.expr.pseudos.animated = fonction (e) {
        retourne w.grep (w.timers, function (t) {
            retourne e === t.elem
        }).longueur
    }, w.offset = {
        setOffset: fonction (e, t, n) {
            var r, i, o, a, s, u, l, c = w.css (e, "position"),
                f = w (e),
                p = {};
            "statique" === c && (e.style.position = "relative"), s = f.offset (), o = w.css (e, "top"), u = w.css (e, " gauche "), (l = (" absolu "=== c ||" fixe "=== c) && (o + u) .indexOf (" auto ")> -1)? (a = (r = f.position ()). top, i = r.left): (a = parseFloat (o) || 0, i = parseFloat (u) || 0), g (t) && ( t = t.call (e, n, w.extend ({}, s))), null! = t.top && (p.top = t.top - s.top + a), null! = t. left && (p.left = t.left - s.left + i), "using" in t? t.utilisation.call (e, p): f.css (p)
        }
    }, w.fn.extend ({
        offset: fonction (e) {
            if (arguments.length) return void 0 === e? ceci: this.each (fonction (t) {
                w.offset.setOffset (ceci, e, t)
            });
            var t, n, r = ceci [0];
            if (r) renvoie r.getClientRects (). length? (t = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {
                haut: t.top + n.pageYOffset,
                gauche: t.gauche + n.pageXOffset
            }): {
                haut: 0,
                gauche: 0
            }
        },
        position: function () {
            if (this [0]) {
                var e, t, n, r = ceci [0],
                    i = {
                        haut: 0,
                        gauche: 0
                    };
                if ("fixed" === w.css (r, "position")) t = r.getBoundingClientRect ();
                autre {
                    t = this.offset (), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
                    while (e && (e === n.body || e === n.documentElement) && "static" === w.css (e, "position")) e = e.parentNode;
                    e && e! == r && 1 === e.nodeType && ((i = w (e) .offset ()). top + = w.css (e, "borderTopWidth",! 0), i.left + = w.css (e, "borderLeftWidth",! 0))
                }
                revenir {
                    haut: t.top - i.top - w.css (r, "marginTop",! 0),
                    gauche: t.gauche - i.gauche - w.css (r, "marginLeft",! 0)
                }
            }
        },
        offsetParent: function () {
            renvoie this.map (function () {
                var e = this.offsetParent;
                while (e && "static" === w.css (e, "position")) e = e.offsetParent;
                retour e || être
            })
        }
    }), w.chaque ({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, fonction (e, t) {
        var n = "pageYOffset" === t;
        w.fn [e] = fonction (r) {
            retourne z (this, function (e, r, i) {
                var o;
                if (y (e)? o = e: 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o? o [t]: e [r];
                o? o.scrollTo (n? o.pageXOffset: i, n? i: o.pageYOffset): e [r] = i
            }, e, r, arguments.length)
        }
    }), w.each (["top", "left"], function (e, t) {
        w.cssHooks [t] = _e (h.pixelPosition, fonction (e, n) {
            si (n) renvoie n = Fe (e, t), We.test (n)? w (e) .position () [t] + "px": n
        })
    }), w.chaque ({
        Hauteur: "hauteur",
        Largeur: "largeur"
    }, fonction (e, t) {
        avec chaque ({
            rembourrage: "intérieur" + e,
            contenu: t,
            "": "extérieur" + e
        }, fonction (n, r) {
            w.fn [r] = fonction (i, o) {
                var a = arguments.length && (n || "boolean"! = typeof i),
                    s = n || (! 0 === i ||! 0 === o? "Margin": "border");
                retourne z (this, function (t, n, i) {
                    var o;
                    retourner y (t)? 0 === r.indexOf ("externe")? t ["intérieur" + e]: t.document.documentElement ["client" + e]: 9 === t.nodeType? (o = t.documentElement, Math.max (t.body ["scroll" + e], o ["scroll" + e], t.body ["offset" + e], o ["offset" + e] , o ["client" + e])): void 0 === i? w.css (t, n, s): w.style (t, n, i, s)
                }, t, a? i: vide 0, a)
            }
        })
    }), w.each ("flou focus focusin focusout redimensionner faire défiler clic dblclick souris bas souris souris souris déplacer la souris souris sortie souris centre souris quitter changement sélectionner soumettre touche enfoncée touche enfoncée touche contextuelle" .split (""), fonction (e, t) {
        w.fn [t] = fonction (e, n) {
            renvoie arguments.length> 0? this.on (t, null, e, n): this.trigger (t)
        }
    }), w.fn.extend ({
        survol: fonction (e, t) {
            renvoie this.mouseenter (e) .mouseleave (t || e)
        }
    }), w.fn.extend ({
        bind: fonction (e, t, n) {
            renvoie this.on (e, null, t, n)
        },
        détachement: fonction (e, t) {
            retourne this.off (e, null, t)
        },
        délégué: function (e, t, n, r) {
            renvoie this.on (t, e, n, r)
        },
        undelegate: function (e, t, n) {
            retourne 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)
        }
    }), w.proxy = fonction (e, t) {
        var n, r, i;
        if ("string" == typeof t && (n = e [t], t = e, e = n), g (e)) return r = o.call (arguments, 2), i = function () {
            retourne e.apply (t || this, r.concat (o.call (arguments)))
        }, i.guid = expuid = exuid || w.guid ++, je
    }, w.holdReady = fonction (e) {
        e? w.readyWait ++: w.ready (! 0)
    }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w. now = Date.now, w.isNumeric = function (e) {
        var t = w.type (e);
        return ("nombre" === t || "chaîne" === t) &&! isNaN (e - parseFloat (e))
    }, "function" == typeof define && define.amd && define ("jquery", [], function () {
        retour w
    });
    var Jt = e.jQuery,
        Kt = e. $;
    retourne w.noConflict = function (t) {
        renvoie e. $ === w && (e. $ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w
    }, t || (e.jQuery = e. $ = w), w
});